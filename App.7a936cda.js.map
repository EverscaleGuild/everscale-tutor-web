{"version":3,"sources":["../node_modules/everscale-inpage-provider/dist/utils.js","../node_modules/everscale-inpage-provider/dist/models.js","../node_modules/everscale-inpage-provider/dist/stream.js","../node_modules/everscale-inpage-provider/dist/contract.js","../node_modules/everscale-inpage-provider/dist/api.js","../node_modules/everscale-inpage-provider/dist/index.js","../build/App.abi.ts","../build/App.addr.ts","App.ts"],"names":[],"mappings":"AIAA,ADAA,AEAA,AJAA,ACAA,AFAA;AICA,ADAA,AEAA,AJAA,ACAA,AFAA;AICA,ADAA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AMJA,ACAA,AJKA,AEAA,AJAA,ACAA,AFAA,OMLA,ACAA,CDAA,ACAA,ODAA,ACAA,GDAe,ACAA;ADAC,ACAA,AJMhB,AEAA,AJAA,ACAA,AFAA,aON2B,IDAG,CAAf;AAAiB,ACAJ,AJO5B,AEAA,AJAA,ACAA,AFAA,WOPmC,EDAO,KAA3B;AAAiC,ACArB,AJQ3B,AEAA,AJAA,ACAA,AFAA,YMRyD,CAAC,MAAD,EAAQ,QAAR,CAA1C;AAA4D,ACA5D,AJSf,AEAA,AJAA,ACAA,AFAA,COTA,cDAuF,CAAC;AAAC,AHUzF,AEAA,AJAA,ACAA,AFAA,YMVgG,aAAR;AAAsB,AHW9G,AEAA,AJAA,ACAA,AFAA,cMXuH,EAA/B;AAAkC,AHY1H,AEAA,AJAA,ACAA,AFAA,eMZoI;AAA5C,AHaxF,AEAA,AJAA,ACAA,AFAA,GMbuF,EAAiD;AAAC,AHczI,AEAA,AJAA,ACAA,AFAA,YMdgJ,UAAR;AAAmB,AHe3J,AEAA,AJAA,ACAA,AFAA,cMfoK,CAAC;AAAC,AHgBtK,AEAA,AJAA,ACAA,AFAA,cMhB6K,aAAR;AAAsB,AHiB3L,AEAA,AJAA,ACAA,AFAA,cMjBkM;AAA7B,AHkBrK,AEAA,AJAA,ACAA,AFAA,KMlBoK,CAA5B;AAAsE,AHmB9M,AEAA,AJAA,ACAA,AFAA,eMnBwN;AAAhF,AHoBxI,AEAA,AJAA,ACAA,AFAA,GMpBuF,EAAqI;AAAC,AHqB7N,AEAA,AJAA,ACAA,AFAA,YMrBoO,kBAAR;AAA2B,AHsBvP,AEAA,AJAA,ACAA,AFAA,cMtBgQ,EAApC;AAAuC,AHuBnQ,AEAA,AJAA,ACAA,AFAA,eMvB6Q,CAAC;AAAC,AHwB/Q,AEAA,AJAA,ACAA,AFAA,cMxBsR,QAAR;AAAiB,AHyB/R,AEAA,AJAA,ACAA,AFAA,cMzBsS;AAAxB,AH0B9Q,AEAA,AJAA,ACAA,AFAA,KM1B6Q;AAAjD,AH2B5N,AEAA,AJAA,ACAA,AFAA,GM3BuF,EAA2N;AAAC,AH4BnT,AEAA,AJAA,ACAA,AFAA,YM5B0T,OAAR;AAAgB,AH6BlU,AEAA,AJAA,ACAA,AFAA,cM7B2U,EAAzB;AAA4B,AH8B9U,AEAA,AJAA,ACAA,AFAA,eM9BwV;AAAtC,AH+BlT,AEAA,AJAA,ACAA,AFAA,GM/BuF,EAAqQ;AAAC,AHgC7V,AEAA,AJAA,ACAA,AFAA,YMhCoW,WAAR;AAAoB,AHiChX,AEAA,AJAA,ACAA,AFAA,cMjCyX,CAAC;AAAC,AHkC3X,AEAA,AJAA,ACAA,AFAA,cMlCkY,MAAR;AAAe,AHmCzY,AEAA,AJAA,ACAA,AFAA,cMnCgZ;AAAtB,AHoC1X,AEAA,AJAA,ACAA,AFAA,KMpCyX,EAAkC;AAAC,AHqC5Z,AEAA,AJAA,ACAA,AFAA,cMrCma,QAAR;AAAiB,AHsC5a,AEAA,AJAA,ACAA,AFAA,cMtCmb;AAAxB,AHuC3Z,AEAA,AJAA,ACAA,AFAA,KMvCyX,EAAqE;AAAC,AHwC/b,AEAA,AJAA,ACAA,AFAA,cMxCsc,QAAR;AAAiB,AHyC/c,AEAA,AJAA,ACAA,AFAA,cMzCsd;AAAxB,AH0C9b,AEAA,AJAA,ACAA,AFAA,KM1CyX,CAA7B;AAAmI,AH2C/d,AEAA,AJAA,ACAA,AFAA,eM3Cye;AAA7I,AH4C5V,AEAA,AJAA,ACAA,AFAA,GM5CuF,EAAsZ;AAAC,AH6C9e,AEAA,AJAA,ACAA,AFAA,YM7Cqf,WAAR;AAAoB,AH8CjgB,AEAA,AJAA,ACAA,AFAA,cM9C0gB,EAA7B;AAAgC,AH+C7gB,AEAA,AJAA,ACAA,AFAA,eM/CuhB,CAAC;AAAC,AHgDzhB,AEAA,AJAA,ACAA,AFAA,cMhDgiB,WAAR;AAAoB,AHiD5iB,AEAA,AJAA,ACAA,AFAA,cMjDmjB;AAA3B,AHkDxhB,AEAA,AJAA,ACAA,AFAA,KMlDuhB;AAA1C,AHmD7e,AEAA,AJAA,ACAA,AFAA,GMnDuF,CAAxE;AAAijB,AHoDhkB,AEAA,AJAA,ACAA,AFAA,UMpDukB,EAAxjB;AAA2jB,AHqD1kB,AEAA,AJAA,ACAA,AFAA,YMrDmlB,EAApkB;AAAukB,AHsDtlB,AEAA,AJAA,ACAA,AFAA,YMtD+lB,CAAC;AAAC,AHuDjmB,AEAA,AJAA,ACAA,AFAA,YMvDwmB,SAAR;AAAkB,AHwDlnB,AEAA,AJAA,ACAA,AFAA,YMxDynB;AAAzB,AHyDhmB,AEAA,AJAA,ACAA,AFAA,GMzD+lB,EAAqC;AAAC,AH0DroB,AEAA,AJAA,ACAA,AFAA,YM1D4oB,YAAR;AAAqB,AH2DzpB,AEAA,AJAA,ACAA,AFAA,YM3DgqB;AAA5B,AH4DpoB,AEAA,AJAA,ACAA,AFAA,GM5D+lB,EAA2E;AAAC,AH6D3qB,AEAA,AJAA,ACAA,AFAA,YM7DkrB,kBAAR;AAA2B,AH8DrsB,AEAA,AJAA,ACAA,AFAA,YM9D4sB;AAAlC,AH+D1qB,AEAA,AJAA,ACAA,AFAA,GM/D+lB,EAAqH;AAAC,AHgErtB,AEAA,AJAA,ACAA,AFAA,YMhE4tB,WAAR;AAAoB,AHiExuB,AEAA,AJAA,ACAA,AFAA,YMjE+uB;AAA3B,AHkEptB,AEAA,AJAA,ACAA,AFAA,GMlE+lB;AAAhlB,AHmEf,AEAA,AJAA,ACAA,AFAA,CMnEA;AHoEA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM3JA,IAAA,2BAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;AL4JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM5JA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;AL6JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,IAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;AL8JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,IAAM,IAAI,GAAG,IAAI,2BAAA,CAAA,iBAAJ,EAAb;AL8JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,SAAS,QAAT,CAAkB,IAAlB,EAAgC,EAAhC,EAAsG;AL8JtG,AEAA,AJAA,ACAA,AM7JI,EAAA,QAAQ,CAAC,gBAAT,CAA0B,kBAAA,MAAA,CAAkB,IAAlB,EAAsB,GAAtB,CAA1B,EAAqD,OAArD,CAA6D,EAA7D;AL8JJ,AEAA,AJAA,ACAA,AM7JC;AL8JD,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,SAAe,eAAf,GAA8B;AL8J9B,AEAA,AJAA,ACAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMlKqB,iBAAA,CAAA;ALmKrB,AEAA,AHAA,AMnKqB;ALoKrB,AEAA,AHAA,AMpKqB,YAAM,QAAQ,EAAd,CAAA;ALqKrB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMvKU,UAAA,QAAQ,GAAG,EAAA,CAAA,IAAA,EAAX;ALwKV,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM3KoB,iBAAA,CAAA;AL4KpB,AEAA,AHAA,AM5KoB;AL6KpB,AEAA,AHAA,AM7KoB,YAAM,QAAQ,CAAC,OAAT,CAAiB,SAAjB,CAA2B,EAA3B,EAA+B,IAA/B,EAAN,CAAA;AL8KpB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMhLc,UAAA,KAAA,GAAM,EAAA,CAAA,IAAA,EAAN;ALiLd,AEAA,AHAA,AMhLQ,UAAA,QAAQ,CACJ,KADI,EAEJ,UAAA,IAAA,EAAI;AL+KhB,AEAA,AHAA,AM/KoB,mBAAA,IAAI,CAAC,SAAL,GAAiB,KAAG,CAAC,SAArB;ALgLpB,AEAA,AHAA,AMhLkD,WAFlC,CAAR;ALmLR,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMpLQ,UAAA,OAAO,CAAC,KAAR,CAAc,OAAd;ALqLR,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM9LC;AL+LD,AEAA,AHAA;ACCA,AEAA,AHAA,AM9LA,SAAe,sBAAf,GAAqC;AL+LrC,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMnMqB,iBAAA,CAAA;ALoMrB,AEAA,AHAA,AMpMqB;ALqMrB,AEAA,AHAA,AMrMqB,YAAM,QAAQ,EAAd,CAAA;ALsMrB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMxMU,UAAA,QAAQ,GAAG,EAAA,CAAA,IAAA,EAAX;ALyMV,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM5MoB,iBAAA,CAAA;AL6MpB,AEAA,AHAA,AM7MoB;AL8MpB,AEAA,AHAA,AM9MoB,YAAM,QAAQ,CAAC,OAAT,CAAiB,gBAAjB,CAAkC,EAAlC,EAAsC,IAAtC,EAAN,CAAA;AL+MpB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMjNc,UAAA,KAAA,GAAM,EAAA,CAAA,IAAA,EAAN;ALkNd,AEAA,AHAA,AMjNQ,UAAA,QAAQ,CACJ,KADI,EAEJ,UAAA,IAAA,EAAI;ALgNhB,AEAA,AHAA,AMhNoB,mBAAA,IAAI,CAAC,SAAL,GAAiB,KAAG,CAAC,MAArB;ALiNpB,AEAA,AHAA,AMjN+C,WAF/B,CAAR;ALoNR,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMrNQ,UAAA,OAAO,CAAC,KAAR,CAAc,OAAd;ALsNR,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM/NC;ALgOD,AEAA,AHAA;ACCA,AEAA,AHAA,AM/NA,SAAe,iBAAf,GAAgC;ALgOhC,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMrOqB,iBAAA,CAAA;ALsOrB,AEAA,AHAA,AMtOqB;ALuOrB,AEAA,AHAA,AMvOqB,YAAM,QAAQ,EAAd,CAAA;ALwOrB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM1OU,UAAA,QAAQ,GAAG,EAAA,CAAA,IAAA,EAAX;AL2OV,AEAA,AHAA,AM1O0B,iBAAA,CAAA;AL2O1B,AEAA,AHAA,AM3O0B;AL4O1B,AEAA,AHAA,AM5O0B,YAAM,IAAI,CAAC,gBAAL,EAAN,CAAA;AL6O1B,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM/OU,UAAA,aAAa,GAAG,EAAA,CAAA,IAAA,EAAhB;ALgPV,AEAA,AHAA,AM/OU,UAAA,SAAS,GAAG,aAAa,CAAC,WAAd,CAA0B,kBAA1B,CAA6C,SAAzD;ALgPV,AEAA,AHAA,AM/OI,UAAA,OAAO,CAAC,KAAR,CAAc,+BAAA,MAAA,CAA+B,SAA/B,CAAd;ALgPJ,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA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","file":"App.7a936cda.js","sourceRoot":"../src","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getUniqueId = exports.mergeTransactions = exports.AddressLiteral = exports.Address = void 0;\n/**\n * @category Utils\n */\nclass Address {\n    constructor(address) {\n        this._address = address;\n    }\n    toString() {\n        return this._address;\n    }\n    equals(other) {\n        if (other instanceof Address) {\n            return this._address == other._address;\n        }\n        else {\n            return this._address == other;\n        }\n    }\n}\nexports.Address = Address;\n/**\n * @category Utils\n */\nclass AddressLiteral extends Address {\n    constructor(address) {\n        super(address);\n    }\n}\nexports.AddressLiteral = AddressLiteral;\n/**\n * Modifies knownTransactions array, merging it with new transactions.\n * All arrays are assumed to be sorted by descending logical time.\n *\n * > Note! This method does not remove duplicates.\n *\n * @param knownTransactions\n * @param newTransactions\n * @param info\n *\n * @category Utils\n */\nfunction mergeTransactions(knownTransactions, newTransactions, info) {\n    if (info.batchType == 'old') {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    if (knownTransactions.length === 0) {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    // Example:\n    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]\n    // new lts: [N-4, N-5]\n    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }\n    // 1. Skip indices until known transaction lt is greater than the biggest in the batch\n    let i = 0;\n    while (i < knownTransactions.length &&\n        knownTransactions[i].id.lt.localeCompare(info.maxLt) >= 0) {\n        ++i;\n    }\n    // 2. Insert new transactions\n    knownTransactions.splice(i, 0, ...newTransactions);\n    return knownTransactions;\n}\nexports.mergeTransactions = mergeTransactions;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseTokensObject = exports.serializeTokensObject = exports.parseAccountInteraction = exports.parsePermissions = exports.parseMessage = exports.serializeMessage = exports.parseTransaction = exports.serializeTransaction = void 0;\nconst utils_1 = require(\"./utils\");\n/**\n * @category Models\n */\nfunction serializeTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: serializeMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(serializeMessage),\n    };\n}\nexports.serializeTransaction = serializeTransaction;\n/**\n * @category Models\n */\nfunction parseTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: parseMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(parseMessage),\n    };\n}\nexports.parseTransaction = parseTransaction;\n/**\n * @category Models\n */\nfunction serializeMessage(message) {\n    return {\n        ...message,\n        src: message.src ? message.src.toString() : undefined,\n        dst: message.dst ? message.dst.toString() : undefined,\n    };\n}\nexports.serializeMessage = serializeMessage;\n/**\n * @category Models\n */\nfunction parseMessage(message) {\n    return {\n        ...message,\n        src: message.src ? new utils_1.Address(message.src) : undefined,\n        dst: message.dst ? new utils_1.Address(message.dst) : undefined,\n    };\n}\nexports.parseMessage = parseMessage;\n/**\n * @category Models\n */\nfunction parsePermissions(permissions) {\n    return {\n        ...permissions,\n        accountInteraction: permissions.accountInteraction ? parseAccountInteraction(permissions.accountInteraction) : undefined,\n    };\n}\nexports.parsePermissions = parsePermissions;\n/**\n * @category Models\n */\nfunction parseAccountInteraction(accountInteraction) {\n    return {\n        ...accountInteraction,\n        address: new utils_1.Address(accountInteraction.address),\n    };\n}\nexports.parseAccountInteraction = parseAccountInteraction;\n/**\n * @category Models\n */\nfunction serializeTokensObject(object) {\n    return serializeTokenValue(object);\n}\nexports.serializeTokensObject = serializeTokensObject;\nfunction serializeTokenValue(token) {\n    if (token instanceof utils_1.Address) {\n        return token.toString();\n    }\n    if (Array.isArray(token)) {\n        const result = [];\n        for (const item of token) {\n            result.push(serializeTokenValue(item));\n        }\n        return result;\n    }\n    else if (token != null && typeof token === 'object') {\n        const result = {};\n        for (const [key, value] of Object.entries(token)) {\n            result[key] = serializeTokenValue(value);\n        }\n        return result;\n    }\n    else {\n        return token;\n    }\n}\n/**\n * @category Models\n */\nfunction parseTokensObject(params, object) {\n    const result = {};\n    for (const param of params) {\n        result[param.name] = parseTokenValue(param, object[param.name]);\n    }\n    return result;\n}\nexports.parseTokensObject = parseTokensObject;\nfunction parseTokenValue(param, token) {\n    if (!param.type.startsWith('map')) {\n        const isArray = param.type.endsWith('[]');\n        const isOptional = !isArray && param.type.startsWith('optional');\n        const rawType = (isArray ?\n            param.type.slice(0, -2) :\n            isOptional ?\n                param.type.slice(9, -1) :\n                param.type);\n        if (isArray) {\n            const rawParam = { name: param.name, type: rawType, components: param.components };\n            const result = [];\n            for (const item of token) {\n                result.push(parseTokenValue(rawParam, item));\n            }\n            return result;\n        }\n        else if (isOptional) {\n            if (token == null) {\n                return null;\n            }\n            else {\n                const rawParam = { name: param.name, type: rawType, components: param.components };\n                return parseTokenValue(rawParam, token);\n            }\n        }\n        else if (rawType == 'tuple') {\n            const result = {};\n            if (param.components != null) {\n                for (const component of param.components) {\n                    result[component.name] = parseTokenValue(component, token[component.name]);\n                }\n            }\n            return result;\n        }\n        else if (rawType == 'address') {\n            return new utils_1.Address(token);\n        }\n        else {\n            return token;\n        }\n    }\n    else {\n        let [keyType, valueType] = param.type.split(',');\n        keyType = keyType.slice(4);\n        valueType = valueType.slice(0, -1);\n        const result = [];\n        for (const [key, value] of token) {\n            result.push([parseTokenValue({\n                    name: '',\n                    type: keyType,\n                }, key), parseTokenValue({\n                    name: '',\n                    type: valueType,\n                    components: param.components,\n                }, value)]);\n        }\n        return result;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriber = void 0;\nconst utils_1 = require(\"./utils\");\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = {};\n        this.scanners = {};\n    }\n    /**\n     * Returns stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address);\n    }\n    /**\n     * Returns stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl(async (onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd,\n                ...filter,\n            });\n            this.scanners[id] = scanner;\n            await scanner.start();\n        }, async () => {\n            const scanner = this.scanners[id];\n            delete this.scanners[id];\n            if (scanner != null) {\n                await scanner.stop();\n            }\n        }, identity);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address);\n    }\n    async unsubscribe() {\n        const subscriptions = Object.assign({}, this.subscriptions);\n        for (const address of Object.keys(this.subscriptions)) {\n            delete this.subscriptions[address];\n        }\n        const scanners = Object.assign({}, this.scanners);\n        for (const id of Object.keys(this.scanners)) {\n            delete this.scanners[id];\n        }\n        await Promise.all(Object.values(subscriptions)\n            .map(async (item) => {\n            const events = Object.assign({}, item);\n            for (const event of Object.keys(events)) {\n                delete item[event];\n            }\n            await Promise.all(Object.values(events).map((eventData) => {\n                if (eventData == null) {\n                    return;\n                }\n                return eventData.subscription.then((item) => {\n                    return item.unsubscribe();\n                }).catch(() => {\n                    // ignore\n                });\n            }));\n        }).concat(Object.values(scanners).map((item) => item.stop())));\n    }\n    _addSubscription(event, address) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            let subscriptions = this.subscriptions[address.toString()];\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            if (eventData == null) {\n                const handlers = {\n                    [id]: { onData, onEnd, queue: new PromiseQueue() },\n                };\n                eventData = {\n                    subscription: this.provider.subscribe(event, {\n                        address,\n                    }).then((subscription) => {\n                        subscription.on('data', (data) => {\n                            Object.values(handlers).forEach(({ onData, queue }) => {\n                                queue.enqueue(() => onData(data));\n                            });\n                        });\n                        subscription.on('unsubscribed', () => {\n                            Object.values(handlers).forEach(({ onEnd, queue }) => {\n                                delete handlers[id];\n                                queue.clear();\n                                queue.enqueue(async () => onEnd());\n                            });\n                        });\n                        return subscription;\n                    }).catch((e) => {\n                        console.error(e);\n                        Object.values(handlers).forEach(({ onEnd, queue }) => {\n                            delete handlers[id];\n                            queue.clear();\n                            queue.enqueue(() => onEnd());\n                        });\n                        throw e;\n                    }),\n                    handlers,\n                };\n                if (subscriptions == null) {\n                    subscriptions = {\n                        [event]: eventData,\n                    };\n                    this.subscriptions[address.toString()] = subscriptions;\n                }\n                else {\n                    subscriptions[event] = eventData;\n                }\n            }\n            else {\n                eventData.handlers[id] = { onData, onEnd, queue: new PromiseQueue() };\n            }\n        }, () => {\n            const subscriptions = this.subscriptions[address.toString()];\n            if (subscriptions == null) {\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                delete eventData.handlers[id];\n                if (Object.keys(eventData.handlers).length === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            if (Object.keys(subscriptions).length === 0) {\n                delete this.subscriptions[address.toString()];\n            }\n        }, identity);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(event, handler) {\n    await handler(event);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n    }\n    first() {\n        return new Promise(async (resolve, reject) => {\n            this.makeProducer(async (event) => {\n                await this.extractor(event, (item) => {\n                    this.stopProducer();\n                    resolve(item);\n                });\n            }, () => reject(new Error('Subscription closed')));\n        });\n    }\n    on(handler) {\n        this.makeProducer(async (event) => {\n            await this.extractor(event, handler);\n        }, () => {\n        });\n    }\n    merge(other) {\n        return new StreamImpl(async (onEvent, onEnd) => {\n            const state = {\n                counter: 0,\n            };\n            const checkEnd = () => {\n                if (++state.counter == 2) {\n                    onEnd();\n                }\n            };\n            this.makeProducer(onEvent, checkEnd);\n            other.makeProducer(onEvent, checkEnd);\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                await handler(item);\n            }\n        }));\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                await handler(newItem);\n            }\n        }));\n    }\n    map(f) {\n        return this.filterMap(f);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                await handler(newItem);\n            }\n        }));\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (state.index >= n) {\n                await handler(item);\n            }\n            else {\n                ++state.index;\n            }\n        }));\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                await handler(item);\n            }\n        }));\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, { address, onData, onEnd, fromLt, fromUtime, }) {\n        this.provider = provider;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.address = address;\n        this.onData = onData;\n        this.onEnd = onEnd;\n        this.fromLt = fromLt;\n        this.fromUtime = fromUtime;\n    }\n    async start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            while (this.isRunning) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.address,\n                        continuation: this.continuation,\n                    });\n                    if (!this.isRunning || transactions.length == null) {\n                        break;\n                    }\n                    const filteredTransactions = transactions.filter((item) => ((this.fromLt == null || item.id.lt > this.fromLt) && ((this.fromUtime == null || item.createdAt > this.fromUtime))));\n                    if (filteredTransactions.length == 0) {\n                        break;\n                    }\n                    const info = {\n                        maxLt: filteredTransactions[0].id.lt,\n                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n                        batchType: 'old',\n                    };\n                    this.queue.enqueue(() => this.onData({\n                        address: this.address,\n                        transactions: filteredTransactions,\n                        info,\n                    }));\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.onEnd());\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.onEnd();\n        }\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TvmException = exports.Contract = void 0;\nconst models_1 = require(\"./models\");\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this._functions = abi.functions.reduce((functions, item) => {\n            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };\n            return functions;\n        }, {});\n        this._events = abi.events.reduce((events, item) => {\n            events[item.name] = { inputs: item.inputs || [] };\n            return events;\n        }, {});\n        this._address = address;\n        class ContractMethodImpl {\n            constructor(provider, functionAbi, abi, address, method, params) {\n                this.provider = provider;\n                this.functionAbi = functionAbi;\n                this.abi = abi;\n                this.address = address;\n                this.method = method;\n                this.params = (0, models_1.serializeTokensObject)(params);\n            }\n            async send(args) {\n                const { transaction } = await this.provider.rawApi.sendMessage({\n                    sender: args.from.toString(),\n                    recipient: this.address.toString(),\n                    amount: args.amount,\n                    bounce: args.bounce == null ? true : args.bounce,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                return (0, models_1.parseTransaction)(transaction);\n            }\n            async sendWithResult(args) {\n                const subscriber = this.provider.createSubscriber();\n                try {\n                    // Parent transaction from wallet\n                    let parentTransaction;\n                    // Child transaction promise\n                    let resolveChildTransactionPromise;\n                    const childTransactionPromise = new Promise((resolve) => {\n                        resolveChildTransactionPromise = (tx) => resolve(tx);\n                    });\n                    // Array for collecting transactions on target before parent transaction promise resolution\n                    const possibleChildren = [];\n                    // Subscribe to this account\n                    subscriber.transactions(this.address)\n                        .flatMap(batch => batch.transactions)\n                        // Listen only messages from sender\n                        .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                        .on((tx) => {\n                        if (parentTransaction == null) {\n                            // If we don't known whether the message was sent just collect all transactions from the sender\n                            possibleChildren.push(tx);\n                        }\n                        else if (parentTransaction.possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0) {\n                            // Resolve promise if transaction was found\n                            resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                        }\n                    });\n                    // Send message\n                    const transaction = await this.send(args);\n                    // Extract all outgoing messages from the parent transaction to this contract\n                    const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n                    // Update stream state\n                    parentTransaction = {\n                        transaction,\n                        possibleMessages,\n                    };\n                    // Check whether child transaction was already found\n                    const alreadyReceived = possibleChildren.find((tx) => {\n                        return possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0;\n                    });\n                    if (alreadyReceived != null) {\n                        resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n                    }\n                    const childTransaction = await childTransactionPromise;\n                    // Parse output\n                    let output = undefined;\n                    try {\n                        const result = await this.provider.rawApi.decodeTransaction({\n                            transaction: (0, models_1.serializeTransaction)(childTransaction),\n                            abi: this.abi,\n                            method: this.method,\n                        });\n                        if (result != null) {\n                            output = this.functionAbi.outputs != null\n                                ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output)\n                                : {};\n                        }\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                    // Done\n                    return {\n                        parentTransaction: parentTransaction.transaction,\n                        childTransaction,\n                        output,\n                    };\n                }\n                finally {\n                    await subscriber.unsubscribe();\n                }\n            }\n            async estimateFees(args) {\n                const { fees } = await this.provider.rawApi.estimateFees({\n                    sender: args.from.toString(),\n                    recipient: this.address.toString(),\n                    amount: args.amount,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                return fees;\n            }\n            async sendExternal(args) {\n                let method = args.withoutSignature === true\n                    ? this.provider.rawApi.sendUnsignedExternalMessage\n                    : this.provider.rawApi.sendExternalMessage;\n                let { transaction, output } = await method({\n                    publicKey: args.publicKey,\n                    recipient: this.address.toString(),\n                    stateInit: args.stateInit,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                    local: args.local,\n                });\n                return {\n                    transaction: (0, models_1.parseTransaction)(transaction),\n                    output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n                };\n            }\n            async call(args = {}) {\n                let { output, code } = await this.provider.rawApi.runLocal({\n                    address: this.address.toString(),\n                    cachedState: args.cachedState,\n                    responsible: args.responsible,\n                    functionCall: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                if (output == null || code != 0) {\n                    throw new TvmException(code);\n                }\n                else {\n                    return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n                }\n            }\n        }\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this._functions[method];\n                return (params) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    async decodeTransaction(args) {\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, input, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this._events[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, input } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProviderNotInitializedException = exports.ProviderNotFoundException = exports.ProviderRpcClient = exports.hasEverscaleProvider = exports.mergeTransactions = exports.AddressLiteral = exports.Address = exports.Subscriber = void 0;\nconst models_1 = require(\"./models\");\nconst utils_1 = require(\"./utils\");\nconst subscriber = __importStar(require(\"./stream\"));\nconst contract = __importStar(require(\"./contract\"));\n__exportStar(require(\"./api\"), exports);\n__exportStar(require(\"./models\"), exports);\n__exportStar(require(\"./contract\"), exports);\nvar stream_1 = require(\"./stream\");\nObject.defineProperty(exports, \"Subscriber\", { enumerable: true, get: function () { return stream_1.Subscriber; } });\nvar utils_2 = require(\"./utils\");\nObject.defineProperty(exports, \"Address\", { enumerable: true, get: function () { return utils_2.Address; } });\nObject.defineProperty(exports, \"AddressLiteral\", { enumerable: true, get: function () { return utils_2.AddressLiteral; } });\nObject.defineProperty(exports, \"mergeTransactions\", { enumerable: true, get: function () { return utils_2.mergeTransactions; } });\nlet ensurePageLoaded;\nif (document.readyState == 'complete') {\n    ensurePageLoaded = Promise.resolve();\n}\nelse {\n    ensurePageLoaded = new Promise((resolve) => {\n        window.addEventListener('load', () => {\n            resolve();\n        });\n    });\n}\n/**\n * @category Provider\n */\nasync function hasEverscaleProvider() {\n    await ensurePageLoaded;\n    return window.__hasEverscaleProvider === true ||\n        window.hasTonProvider === true;\n}\nexports.hasEverscaleProvider = hasEverscaleProvider;\n/**\n * @category Provider\n */\nclass ProviderRpcClient {\n    constructor(properties = {}) {\n        this._subscriptions = {};\n        this._contractSubscriptions = {};\n        const self = this;\n        // Create contract proxy type\n        class ProviderContract extends contract.Contract {\n            constructor(abi, address) {\n                super(self, abi, address);\n            }\n        }\n        this.Contract = ProviderContract;\n        // Create subscriber proxy type\n        class ProviderSubscriber extends subscriber.Subscriber {\n            constructor() {\n                super(self);\n            }\n        }\n        this.Subscriber = ProviderSubscriber;\n        this._properties = properties;\n        // Wrap provider requests\n        this._api = new Proxy({}, {\n            get: (_object, method) => (params) => {\n                if (this._provider != null) {\n                    return this._provider.request({ method, params: params });\n                }\n                else {\n                    throw new ProviderNotInitializedException();\n                }\n            },\n        });\n        // Initialize provider with injected object by default\n        this._provider = window.__ever || window.ton;\n        if (this._provider != null) {\n            // Provider as already injected\n            this._mainInitializationPromise = Promise.resolve();\n        }\n        else {\n            // Wait until page is loaded and initialization complete\n            this._mainInitializationPromise = hasEverscaleProvider().then((hasProvider) => new Promise((resolve, reject) => {\n                if (!hasProvider) {\n                    // Fully loaded page doesn't even contain provider flag\n                    reject(new ProviderNotFoundException());\n                    return;\n                }\n                // Wait injected provider initialization otherwise\n                this._provider = window.__ever || window.ton;\n                if (this._provider != null) {\n                    resolve();\n                }\n                else {\n                    const eventName = window.__hasEverscaleProvider === true ? 'ever#initialized' : 'ton#initialized';\n                    window.addEventListener(eventName, (_data) => {\n                        this._provider = window.__ever || window.ton;\n                        resolve();\n                    });\n                }\n            }));\n        }\n        // Will only register handlers for successfully loaded injected provider\n        this._mainInitializationPromise.then(() => {\n            if (this._provider != null) {\n                this._registerEventHandlers(this._provider);\n            }\n        });\n    }\n    /**\n     * Checks whether this page has injected Everscale provider\n     */\n    async hasProvider() {\n        return hasEverscaleProvider();\n    }\n    /**\n     * Waits until provider api will be available. Calls `fallback` if no provider was found\n     *\n     * @throws ProviderNotFoundException when no provider found\n     */\n    async ensureInitialized() {\n        try {\n            await this._mainInitializationPromise;\n        }\n        catch (e) {\n            if (this._properties.fallback == null) {\n                throw e;\n            }\n            if (this._additionalInitializationPromise == null) {\n                this._additionalInitializationPromise = this._properties.fallback().then(async (provider) => {\n                    this._provider = provider;\n                    this._registerEventHandlers(this._provider);\n                });\n            }\n            await this._additionalInitializationPromise;\n        }\n    }\n    /**\n     * Whether provider api is ready\n     */\n    get isInitialized() {\n        return this._provider != null;\n    }\n    /**\n     * Raw provider\n     */\n    get raw() {\n        if (this._provider != null) {\n            return this._provider;\n        }\n        else {\n            throw new ProviderNotInitializedException();\n        }\n    }\n    /**\n     * Raw provider api\n     */\n    get rawApi() {\n        return this._api;\n    }\n    /**\n     * Creates typed contract wrapper.\n     *\n     * @param abi Readonly object (must be declared with `as const`)\n     * @param address Default contract address\n     *\n     * @deprecated `new ever.Contract(abi, address)` should be used instead\n     */\n    createContract(abi, address) {\n        return new this.Contract(abi, address);\n    }\n    /**\n     * Creates subscriptions group\n     *\n     * @deprecated `new ever.Subscriber()` should be used instead\n     */\n    createSubscriber() {\n        return new this.Subscriber();\n    }\n    /**\n     * Requests new permissions for current origin.\n     * Shows an approval window to the user.\n     * Will overwrite already existing permissions\n     *\n     * ---\n     * Required permissions: none\n     */\n    async requestPermissions(args) {\n        const result = await this._api.requestPermissions({\n            permissions: args.permissions,\n        });\n        return (0, models_1.parsePermissions)(result);\n    }\n    /**\n     * Updates `accountInteraction` permission value\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async changeAccount() {\n        await this._api.changeAccount();\n    }\n    /**\n     * Removes all permissions for current origin and stops all subscriptions\n     */\n    async disconnect() {\n        await this._api.disconnect();\n    }\n    async subscribe(eventName, params) {\n        class SubscriptionImpl {\n            constructor(_subscribe, _unsubscribe) {\n                this._subscribe = _subscribe;\n                this._unsubscribe = _unsubscribe;\n                this._listeners = {\n                    ['data']: [],\n                    ['subscribed']: [],\n                    ['unsubscribed']: [],\n                };\n            }\n            on(eventName, listener) {\n                this._listeners[eventName].push(listener);\n                return this;\n            }\n            async subscribe() {\n                await this._subscribe(this);\n                for (const handler of this._listeners['subscribed']) {\n                    handler();\n                }\n            }\n            async unsubscribe() {\n                await this._unsubscribe();\n                for (const handler of this._listeners['unsubscribed']) {\n                    handler();\n                }\n            }\n            notify(data) {\n                for (const handler of this._listeners['data']) {\n                    handler(data);\n                }\n            }\n        }\n        let existingSubscriptions = this._getEventSubscriptions(eventName);\n        const id = (0, utils_1.getUniqueId)();\n        switch (eventName) {\n            case 'connected':\n            case 'disconnected':\n            case 'networkChanged':\n            case 'permissionsChanged':\n            case 'loggedOut': {\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions[id] != null) {\n                        return;\n                    }\n                    existingSubscriptions[id] = (data) => {\n                        subscription.notify(data);\n                    };\n                }, async () => {\n                    delete existingSubscriptions[id];\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            case 'transactionsFound':\n            case 'contractStateChanged': {\n                const address = params.address.toString();\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions[id] != null) {\n                        return;\n                    }\n                    existingSubscriptions[id] = ((data) => {\n                        if (data.address.toString() == address) {\n                            subscription.notify(data);\n                        }\n                    });\n                    let contractSubscriptions = this._contractSubscriptions[address];\n                    if (contractSubscriptions == null) {\n                        contractSubscriptions = {};\n                        this._contractSubscriptions[address] = contractSubscriptions;\n                    }\n                    contractSubscriptions[id] = {\n                        state: eventName == 'contractStateChanged',\n                        transactions: eventName == 'transactionsFound',\n                    };\n                    const { total, withoutExcluded, } = foldSubscriptions(Object.values(contractSubscriptions), contractSubscriptions[id]);\n                    try {\n                        if (total.transactions != withoutExcluded.transactions || total.state != withoutExcluded.state) {\n                            await this.rawApi.subscribe({ address, subscriptions: total });\n                        }\n                    }\n                    catch (e) {\n                        delete existingSubscriptions[id];\n                        delete contractSubscriptions[id];\n                        throw e;\n                    }\n                }, async () => {\n                    delete existingSubscriptions[id];\n                    const contractSubscriptions = this._contractSubscriptions[address];\n                    if (contractSubscriptions == null) {\n                        return;\n                    }\n                    const updates = contractSubscriptions[id];\n                    const { total, withoutExcluded } = foldSubscriptions(Object.values(contractSubscriptions), updates);\n                    delete contractSubscriptions[id];\n                    if (!withoutExcluded.transactions && !withoutExcluded.state) {\n                        await this.rawApi.unsubscribe({ address });\n                    }\n                    else if (total.transactions != withoutExcluded.transactions || total.state != withoutExcluded.state) {\n                        await this.rawApi.subscribe({ address, subscriptions: withoutExcluded });\n                    }\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            default: {\n                throw new Error(`Unknown event ${eventName}`);\n            }\n        }\n    }\n    /**\n     * Returns provider api state\n     *\n     * ---\n     * Required permissions: none\n     */\n    async getProviderState() {\n        const state = await this._api.getProviderState();\n        return {\n            ...state,\n            permissions: (0, models_1.parsePermissions)(state.permissions),\n        };\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullContractState(args) {\n        return await this._api.getFullContractState({\n            address: args.address.toString(),\n        });\n    }\n    /**\n     * Requests accounts with specified code hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getAccountsByCodeHash(args) {\n        const { accounts, continuation } = await this._api.getAccountsByCodeHash({\n            ...args,\n        });\n        return {\n            accounts: accounts.map((address) => new utils_1.Address(address)),\n            continuation,\n        };\n    }\n    /**\n     * Requests contract transactions\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransactions(args) {\n        const { transactions, continuation, info } = await this._api.getTransactions({\n            ...args,\n            address: args.address.toString(),\n        });\n        return {\n            transactions: transactions.map(models_1.parseTransaction),\n            continuation,\n            info,\n        };\n    }\n    /**\n     * Searches transaction by hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransaction(args) {\n        const { transaction } = await this._api.getTransaction({\n            ...args,\n        });\n        return {\n            transaction: transaction ? (0, models_1.parseTransaction)(transaction) : undefined,\n        };\n    }\n    /**\n     * Calculates contract address from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getExpectedAddress(abi, args) {\n        const { address } = await this._api.getExpectedAddress({\n            abi: JSON.stringify(abi),\n            ...args,\n            initParams: (0, models_1.serializeTokensObject)(args.initParams),\n        });\n        return new utils_1.Address(address);\n    }\n    /**\n     * Computes hash of base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBocHash(boc) {\n        return await this._api.getBocHash({\n            boc,\n        }).then(({ hash }) => hash);\n    }\n    /**\n     * Creates base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async packIntoCell(args) {\n        return await this._api.packIntoCell({\n            structure: args.structure,\n            data: (0, models_1.serializeTokensObject)(args.data),\n        });\n    }\n    /**\n     * Decodes base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async unpackFromCell(args) {\n        const { data } = await this._api.unpackFromCell({\n            ...args,\n            structure: args.structure,\n        });\n        return {\n            data: (0, models_1.parseTokensObject)(args.structure, data),\n        };\n    }\n    /**\n     * Extracts public key from raw account state\n     *\n     * **NOTE:** can only be used on contracts which are deployed and has `pubkey` header\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async extractPublicKey(boc) {\n        const { publicKey } = await this._api.extractPublicKey({\n            boc,\n        });\n        return publicKey;\n    }\n    /**\n     * Converts base64 encoded contract code into tvc with default init data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async codeToTvc(code) {\n        const { tvc } = await this._api.codeToTvc({\n            code,\n        });\n        return tvc;\n    }\n    /**\n     * Splits base64 encoded state init into code and data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async splitTvc(tvc) {\n        return await this._api.splitTvc({\n            tvc,\n        });\n    }\n    /**\n     * Adds asset to the selected account\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async addAsset(args) {\n        let params;\n        switch (args.type) {\n            case 'tip3_token': {\n                params = {\n                    rootContract: args.params.rootContract.toString(),\n                };\n                break;\n            }\n            default:\n                throw new Error('Unknown asset type');\n        }\n        return await this._api.addAsset({\n            account: args.account.toString(),\n            type: args.type,\n            params,\n        });\n    }\n    async verifySignature(args) {\n        return await this._api.verifySignature(args);\n    }\n    /**\n     * Signs arbitrary data.\n     *\n     * NOTE: hashes data before signing. Use `signDataRaw` to sign without hash.\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signData(args) {\n        return await this._api.signData(args);\n    }\n    /**\n     * Signs arbitrary data without hashing it\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signDataRaw(args) {\n        return await this._api.signDataRaw(args);\n    }\n    /**\n     * Encrypts arbitrary data with specified algorithm for each specified recipient\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async encryptData(args) {\n        const { encryptedData } = await this._api.encryptData(args);\n        return encryptedData;\n    }\n    /**\n     * Decrypts encrypted data. Returns base64 encoded data\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async decryptData(encryptedData) {\n        const { data } = await this._api.decryptData({ encryptedData });\n        return data;\n    }\n    /**\n     * Sends internal message from user account.\n     * Shows an approval window to the user.\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessage(args) {\n        const { transaction } = await this._api.sendMessage({\n            ...args,\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n        };\n    }\n    _registerEventHandlers(provider) {\n        const knownEvents = {\n            'connected': (data) => data,\n            'disconnected': (data) => data,\n            'transactionsFound': (data) => ({\n                address: new utils_1.Address(data.address),\n                transactions: data.transactions.map(models_1.parseTransaction),\n                info: data.info,\n            }),\n            'contractStateChanged': (data) => ({\n                address: new utils_1.Address(data.address),\n                state: data.state,\n            }),\n            'networkChanged': data => data,\n            'permissionsChanged': (data) => ({\n                permissions: (0, models_1.parsePermissions)(data.permissions),\n            }),\n            'loggedOut': data => data,\n        };\n        for (const [eventName, extractor] of Object.entries(knownEvents)) {\n            provider.addListener(eventName, (data) => {\n                const handlers = this._subscriptions[eventName];\n                if (handlers == null) {\n                    return;\n                }\n                const parsed = extractor(data);\n                for (const handler of Object.values(handlers)) {\n                    handler(parsed);\n                }\n            });\n        }\n    }\n    _getEventSubscriptions(eventName) {\n        let existingSubscriptions = this._subscriptions[eventName];\n        if (existingSubscriptions == null) {\n            existingSubscriptions = {};\n            this._subscriptions[eventName] = existingSubscriptions;\n        }\n        return existingSubscriptions;\n    }\n}\nexports.ProviderRpcClient = ProviderRpcClient;\n/**\n * @category Provider\n */\nclass ProviderNotFoundException extends Error {\n    constructor() {\n        super('Everscale provider was not found');\n    }\n}\nexports.ProviderNotFoundException = ProviderNotFoundException;\n/**\n * @category Provider\n */\nclass ProviderNotInitializedException extends Error {\n    constructor() {\n        super('Everscale provider was not initialized yet');\n    }\n}\nexports.ProviderNotInitializedException = ProviderNotInitializedException;\nfunction foldSubscriptions(subscriptions, except) {\n    const total = { state: false, transactions: false };\n    const withoutExcluded = Object.assign({}, total);\n    for (const item of subscriptions) {\n        if (withoutExcluded.transactions && withoutExcluded.state) {\n            break;\n        }\n        total.state || (total.state = item.state);\n        total.transactions || (total.transactions = item.transactions);\n        if (item != except) {\n            withoutExcluded.state || (withoutExcluded.state = item.state);\n            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);\n        }\n    }\n    return { total, withoutExcluded };\n}\n","export default {\"ABI version\":2,\"version\":\"2.2\",\"header\":[\"time\",\"expire\"],\"functions\":[{\"name\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"name\":\"destruct\",\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"outputs\":[]},{\"name\":\"renderHelloWorld\",\"inputs\":[],\"outputs\":[{\"name\":\"value0\",\"type\":\"string\"}]},{\"name\":\"touch\",\"inputs\":[],\"outputs\":[]},{\"name\":\"sendValue\",\"inputs\":[{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"bounce\",\"type\":\"bool\"}],\"outputs\":[]},{\"name\":\"timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint32\"}]}],\"data\":[],\"events\":[],\"fields\":[{\"name\":\"_pubkey\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint64\"},{\"name\":\"_constructorFlag\",\"type\":\"bool\"},{\"name\":\"timestamp\",\"type\":\"uint32\"}]} as const\n","export default {\"testnet\": {\"App\": \"0:440b5e49eff4ba34efd9a66afcd7c9334566ca4f16723657c2879316fde999c6\"},}\n","import {Address, ProviderRpcClient,} from 'everscale-inpage-provider';\nimport abi from '../build/App.abi';\nimport addr from '../build/App.addr';\n\nconst ever = new ProviderRpcClient();\n\nfunction behavior(name: string, fn: (elem: HTMLElement | HTMLButtonElement | HTMLInputElement) => void) {\n    document.querySelectorAll(`[data-behavior=${name}]`).forEach(fn);\n}\n\nasync function timestampAction() {\n    const contract = await Contract();\n    try {\n        const out = await contract.methods.timestamp({}).call();\n        behavior(\n            'out',\n            elem => elem.innerText = out.timestamp\n        );\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nasync function renderHelloWorldAction() {\n    const contract = await Contract();\n    try {\n        const out = await contract.methods.renderHelloWorld({}).call();\n        behavior(\n            'out',\n            elem => elem.innerText = out.value0\n        );\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nasync function touchActionAction() {\n    const contract = await Contract();\n    const providerState = await ever.getProviderState();\n    const publicKey = providerState.permissions.accountInteraction.publicKey;\n    console.error(`touchActionAction publicKey=${publicKey}`);\n    try {\n        const response = await contract.methods.touch({}).sendExternal({\n            publicKey,\n            withoutSignature: true,\n        });\n        console.log(response);\n        const trx = response.transaction;\n        const out = `aborted=${trx.aborted} <a href=\"${await explorerTransactionDetails(trx.id.hash)}\">trx=${trx.id.hash}</a>`;\n        behavior('out',elem => elem.innerHTML = out);\n    } catch (error) {\n        console.error(error);\n    }\n}\n\nasync function explorerTransactionDetails(hash: string) {\n    const providerState = await ever.getProviderState();\n    switch (providerState.selectedConnection) {\n        case 'mainnet':\n            return `https://ever.live/transactions/transactionDetails?id=${hash}`\n        case 'testnet':\n            return `https://net.ever.live/transactions/transactionDetails?id=${hash}`\n        case 'localnet':\n            return `http://localhost/transactions/transactionDetails?id=${hash}`\n        default:\n            return `#${hash}`\n    }\n}\n\nfunction requestPermissions() {\n    return ever.requestPermissions({\n        permissions: [\n            'basic',\n            'accountInteraction',\n        ],\n    });\n}\n\nasync function connect() {\n    await ever.requestPermissions({\n        permissions: [\n            'basic',\n            'accountInteraction',\n        ],\n    });\n}\n\nasync function checkConnect() {\n    const providerState = await ever.getProviderState();\n    const permissions = providerState.permissions;\n    const network = providerState.selectedConnection;\n    if (!permissions.accountInteraction) {\n        behavior('connect', elem => elem.onclick = requestPermissions);\n        switchScreen(\"login\");\n        const connectText = elem => {\n            const disabled = !contractAddress(network);\n            if (\"disabled\" in elem) elem.disabled = disabled;\n            elem.innerText = disabled ? `Contract not deployd into ${network}` : `Connect with ${network} for interact contract`;\n        };\n        behavior('connect', connectText);\n    } else {\n        // INFO for transactionsFound and contractStateChanged need permissions\n        const providerState = await ever.getProviderState();\n        (await ever.subscribe('transactionsFound', {\n            address: contractAddress(providerState.selectedConnection),\n        })).on('data', (event) => {\n            console.log(':', {\n                address: event.address,\n                transactions: event.transactions,\n                info: event.info,\n            });\n        });\n        (await ever.subscribe('contractStateChanged', {\n            address: contractAddress(providerState.selectedConnection),\n        })).on('data', (event) => {\n            console.log('permissionsChanged:', {\n                address: event.address,\n                state: event.state,\n            });\n        });\n        switchScreen(\"main\");\n        const account = permissions.accountInteraction;\n        behavior('address', elem => elem.innerText = account.address.toString());\n        behavior('publicKey', elem => elem.innerText = account.publicKey.toString());\n        behavior('timestampAction', elem => elem.onclick = timestampAction);\n        behavior('renderHelloWorldAction', elem => elem.onclick = renderHelloWorldAction);\n        behavior('touchActionAction', elem => elem.onclick = touchActionAction);\n    }\n}\nasync function setNetworkChanged(network: string) {\n    const mod = network === 'mainnet' ? 'success' : 'secondary';\n    const out = `<span class=\"badge bg-${mod}\">${network}</span>`;\n    behavior('network',elem => elem.innerHTML = out);\n    await checkConnect();\n}\n\nfunction contractAddress(network: string, name = \"App\"): Address {\n    return new Address(addr[network][name] ?? \"\");\n}\n\nasync function Contract() {\n    const providerState = await ever.getProviderState();\n    const address = contractAddress(providerState.selectedConnection);\n    return new ever.Contract(abi, address);\n}\n\nfunction switchScreen(to: string) {\n    [\n        \"extension\",\n        \"login\",\n        \"main\",\n    ].forEach(screen => {\n        const switcher = elem => elem.style.display = (to === screen ? 'block' : 'none');\n        behavior(screen, switcher);\n    });\n}\n\nasync function mainFlow() {\n    const providerState = await ever.getProviderState();\n    await setNetworkChanged(providerState.selectedConnection);\n    (await ever.subscribe('networkChanged')).on('data', event => {\n        console.log('networkChanged:', event.selectedConnection);\n        setNetworkChanged(event.selectedConnection);\n    });\n    (await ever.subscribe('permissionsChanged')).on('data', async (event) => {\n        console.log('permissionsChanged:', event.permissions);\n        await checkConnect();\n    });\n}\n\nasync function App() {\n    if ((await ever.hasProvider())) {\n        try {\n            await ever.ensureInitialized();\n            await mainFlow();\n        } catch (error) {\n            throw error; // TODO handle it\n        }\n    } else {\n        switchScreen(\"extension\");\n    }\n}\n\nApp().catch((error) => console.error(error));\n"]}