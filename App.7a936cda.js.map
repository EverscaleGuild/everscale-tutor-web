{"version":3,"sources":["../node_modules/everscale-inpage-provider/dist/utils.js","../node_modules/everscale-inpage-provider/dist/models.js","../node_modules/everscale-inpage-provider/dist/stream.js","../node_modules/everscale-inpage-provider/dist/contract.js","../node_modules/everscale-inpage-provider/dist/api.js","../node_modules/everscale-inpage-provider/dist/index.js","../build/App.abi.ts","../build/App.addr.ts","App.ts"],"names":[],"mappings":"AIAA,ADAA,AEAA,AJAA,ACAA,AFAA;AICA,ADAA,AEAA,AJAA,ACAA,AFAA;AICA,ADAA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AMJA,ACAA,AJKA,AEAA,AJAA,ACAA,AFAA,OMLA,ACAA,CDAA,ACAA,ODAA,ACAA,GDAe,ACAA;ADAC,ACAA,AJMhB,AEAA,AJAA,ACAA,AFAA,aON2B,IDAG,CAAf;AAAiB,ACAJ,AJO5B,AEAA,AJAA,ACAA,AFAA,WOPmC,EDAO,KAA3B;AAAiC,ACArB,AJQ3B,AEAA,AJAA,ACAA,AFAA,YMRyD,CAAC,MAAD,EAAQ,QAAR,CAA1C;AAA4D,ACA5D,AJSf,AEAA,AJAA,ACAA,AFAA,COTA,cDAuF,CAAC;AAAC,AHUzF,AEAA,AJAA,ACAA,AFAA,YMVgG,aAAR;AAAsB,AHW9G,AEAA,AJAA,ACAA,AFAA,cMXuH,EAA/B;AAAkC,AHY1H,AEAA,AJAA,ACAA,AFAA,eMZoI;AAA5C,AHaxF,AEAA,AJAA,ACAA,AFAA,GMbuF,EAAiD;AAAC,AHczI,AEAA,AJAA,ACAA,AFAA,YMdgJ,kBAAR;AAA2B,AHenK,AEAA,AJAA,ACAA,AFAA,cMf4K,EAApC;AAAuC,AHgB/K,AEAA,AJAA,ACAA,AFAA,eMhByL,CAAC;AAAC,AHiB3L,AEAA,AJAA,ACAA,AFAA,cMjBkM,QAAR;AAAiB,AHkB3M,AEAA,AJAA,ACAA,AFAA,cMlBkN;AAAxB,AHmB1L,AEAA,AJAA,ACAA,AFAA,KMnByL;AAAjD,AHoBxI,AEAA,AJAA,ACAA,AFAA,GMpBuF,EAAuI;AAAC,AHqB/N,AEAA,AJAA,ACAA,AFAA,YMrBsO,OAAR;AAAgB,AHsB9O,AEAA,AJAA,ACAA,AFAA,cMtBuP,EAAzB;AAA4B,AHuB1P,AEAA,AJAA,ACAA,AFAA,eMvBoQ;AAAtC,AHwB9N,AEAA,AJAA,ACAA,AFAA,GMxBuF,EAAiL;AAAC,AHyBzQ,AEAA,AJAA,ACAA,AFAA,YMzBgR,WAAR;AAAoB,AH0B5R,AEAA,AJAA,ACAA,AFAA,cM1BqS,CAAC;AAAC,AH2BvS,AEAA,AJAA,ACAA,AFAA,cM3B8S,MAAR;AAAe,AH4BrT,AEAA,AJAA,ACAA,AFAA,cM5B4T;AAAtB,AH6BtS,AEAA,AJAA,ACAA,AFAA,KM7BqS,EAAkC;AAAC,AH8BxU,AEAA,AJAA,ACAA,AFAA,cM9B+U,QAAR;AAAiB,AH+BxV,AEAA,AJAA,ACAA,AFAA,cM/B+V;AAAxB,AHgCvU,AEAA,AJAA,ACAA,AFAA,KMhCqS,EAAqE;AAAC,AHiC3W,AEAA,AJAA,ACAA,AFAA,cMjCkX,QAAR;AAAiB,AHkC3X,AEAA,AJAA,ACAA,AFAA,cMlCkY;AAAxB,AHmC1W,AEAA,AJAA,ACAA,AFAA,KMnCqS,CAA7B;AAAmI,AHoC3Y,AEAA,AJAA,ACAA,AFAA,eMpCqZ;AAA7I,AHqCxQ,AEAA,AJAA,ACAA,AFAA,GMrCuF,EAAkU;AAAC,AHsC1Z,AEAA,AJAA,ACAA,AFAA,YMtCia,WAAR;AAAoB,AHuC7a,AEAA,AJAA,ACAA,AFAA,cMvCsb,EAA7B;AAAgC,AHwCzb,AEAA,AJAA,ACAA,AFAA,eMxCmc,CAAC;AAAC,AHyCrc,AEAA,AJAA,ACAA,AFAA,cMzC4c,WAAR;AAAoB,AH0Cxd,AEAA,AJAA,ACAA,AFAA,cM1C+d;AAA3B,AH2Cpc,AEAA,AJAA,ACAA,AFAA,KM3Cmc;AAA1C,AH4CzZ,AEAA,AJAA,ACAA,AFAA,GM5CuF,CAAxE;AAA6d,AH6C5e,AEAA,AJAA,ACAA,AFAA,UM7Cmf,EAApe;AAAue,AH8Ctf,AEAA,AJAA,ACAA,AFAA,YM9C+f,EAAhf;AAAmf,AH+ClgB,AEAA,AJAA,ACAA,AFAA,YM/C2gB,CAAC;AAAC,AHgD7gB,AEAA,AJAA,ACAA,AFAA,YMhDohB,SAAR;AAAkB,AHiD9hB,AEAA,AJAA,ACAA,AFAA,YMjDqiB;AAAzB,AHkD5gB,AEAA,AJAA,ACAA,AFAA,GMlD2gB,EAAqC;AAAC,AHmDjjB,AEAA,AJAA,ACAA,AFAA,YMnDwjB,YAAR;AAAqB,AHoDrkB,AEAA,AJAA,ACAA,AFAA,YMpD4kB;AAA5B,AHqDhjB,AEAA,AJAA,ACAA,AFAA,GMrD2gB,EAA2E;AAAC,AHsDvlB,AEAA,AJAA,ACAA,AFAA,YMtD8lB,kBAAR;AAA2B,AHuDjnB,AEAA,AJAA,ACAA,AFAA,YMvDwnB;AAAlC,AHwDtlB,AEAA,AJAA,ACAA,AFAA,GMxD2gB,EAAqH;AAAC,AHyDjoB,AEAA,AJAA,ACAA,AFAA,YMzDwoB,WAAR;AAAoB,AH0DppB,AEAA,AJAA,ACAA,AFAA,YM1D2pB;AAA3B,AH2DhoB,AEAA,AJAA,ACAA,AFAA,GM3D2gB;AAA5f,AH4Df,AEAA,AJAA,ACAA,AFAA,CM5DA;AH6DA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA,AFAA;AGCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM3JA,IAAA,2BAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;AL4JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM5JA,IAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;AL6JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,IAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;AL8JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,IAAM,IAAI,GAAG,IAAI,2BAAA,CAAA,iBAAJ,EAAb;AL8JA,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,SAAS,QAAT,CAAkB,IAAlB,EAAgC,EAAhC,EAAsG;AL8JtG,AEAA,AJAA,ACAA,AM7JI,EAAA,QAAQ,CAAC,gBAAT,CAA0B,kBAAA,MAAA,CAAkB,IAAlB,EAAsB,GAAtB,CAA1B,EAAqD,OAArD,CAA6D,EAA7D;AL8JJ,AEAA,AJAA,ACAA,AM7JC;AL8JD,AEAA,AJAA,ACAA;ACCA,AEAA,AJAA,ACAA,AM7JA,SAAS,kBAAT,GAA2B;AL8J3B,AEAA,AJAA,ACAA,AM7JI,SAAO,IAAI,CAAC,kBAAL,CAAwB;AL8JnC,AEAA,AHAA,AM7JQ,IAAA,WAAW,EAAE,CACT,OADS,EAET,oBAFS;AL8JrB,AEAA,AHAA,AM/JmC,GAAxB,CAAP;ALgKJ,AEAA,AHAA,AM1JC;AL2JD,AEAA,AHAA;ACCA,AEAA,AHAA,AM1JA,SAAe,OAAf,GAAsB;AL2JtB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM9JI,iBAAA,CAAA;AL+JJ,AEAA,AHAA,AM/JI;ALgKJ,AEAA,AHAA,AMhKI,YAAM,IAAI,CAAC,kBAAL,CAAwB;ALiKlC,AEAA,AHAA,AMhKQ,YAAA,WAAW,EAAE,CACT,OADS,EAET,oBAFS;ALiKrB,AEAA,AHAA,AMlKkC,WAAxB,CAAN,CAAA;ALmKJ,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMrKI,UAAA,EAAA,CAAA,IAAA;ALsKJ,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMvKC;ALwKD,AEAA,AHAA;ACCA,AEAA,AHAA,AMvKA,SAAS,iBAAT,CAA2B,OAA3B,EAA0C;ALwK1C,AEAA,AHAA,AMvKI,MAAM,GAAG,GAAG,OAAO,KAAK,SAAZ,GAAwB,SAAxB,GAAoC,WAAhD;ALwKJ,AEAA,AHAA,AMvKI,EAAA,QAAQ,CACJ,SADI,EAEJ,UAAA,IAAA,EAAI;ALsKZ,AEAA,AHAA,AMtKgB,WAAA,IAAI,CAAC,SAAL,GAAiB,0BAAA,MAAA,CAAyB,GAAzB,EAA4B,KAA5B,EAA4B,MAA5B,CAAiC,OAAjC,EAAwC,SAAxC,CAAjB;ALuKhB,AEAA,AHAA,AMvKkF,GAFtE,CAAR;AL0KJ,AEAA,AHAA,AMtKI,EAAA,QAAQ,CACJ,SADI,EAEJ,UAAA,IAAA,EAAI;ALqKZ,AEAA,AHAA,AMpKY,QAAM,QAAQ,GAAG,CAAC,eAAe,CAAC,OAAD,CAAjC;ALqKZ,AEAA,AHAA,AMpKY,QAAI,cAAc,IAAlB,EAAwB,IAAI,CAAC,QAAL,GAAgB,QAAhB;ALqKpC,AEAA,AHAA,AMpKY,IAAA,IAAI,CAAC,SAAL,GAAiB,QAAQ,GAAG,6BAAA,MAAA,CAA6B,OAA7B,CAAH,GAA2C,gBAAA,MAAA,CAAgB,OAAhB,EAAuB,wBAAvB,CAApE;ALqKZ,AEAA,AHAA,AMpKS,GANG,CAAR;AL2KJ,AEAA,AHAA,AMnKC;ALoKD,AEAA,AHAA;ACCA,AEAA,AHAA,AMnKA,SAAS,eAAT,CAAyB,OAAzB,EAA0C,IAA1C,EAAsD;ALoKtD,AEAA,AHAA,AMpK0C,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;ALqK1C,AEAA,AHAA,AMrK0C,IAAA,IAAA,GAAA,KAAA;ALsK1C,AEAA,AHAA,AMtKsD;ALuKtD,AEAA,AHAA;ACCA,AEAA,AHAA,AMvKI,MAAI,UAAA,CAAA,OAAA,CAAK,OAAL,KAAiB,UAAA,CAAA,OAAA,CAAK,OAAL,EAAc,IAAd,CAArB,EAA0C;ALwK9C,AEAA,AHAA,AMvKQ,WAAO,IAAI,2BAAA,CAAA,OAAJ,CAAY,UAAA,CAAA,OAAA,CAAK,OAAL,EAAc,IAAd,CAAZ,CAAP;ALwKR,AEAA,AHAA,AMvKK;ALwKL,AEAA,AHAA;ACCA,AEAA,AHAA,AMxKI,SAAO,IAAP;ALyKJ,AEAA,AHAA,AMxKC;ALyKD,AEAA,AHAA;ACCA,AEAA,AHAA,AMxKA,SAAe,GAAf,GAAkB;ALyKlB,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM7KU,iBAAA,CAAA;AL8KV,AEAA,AHAA,AM9KU;AL+KV,AEAA,AHAA,AM/KU,YAAM,IAAI,CAAC,WAAL,EAAN,CAAA;ALgLV,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMlLI,cAAI,CAAE,EAAA,CAAA,IAAA,EAAN,EAAiC;ALmLrC,AEAA,AHAA,AMlLQ,YAAA,QAAQ,CAAC,WAAD,EAAc,UAAA,IAAA,EAAI;ALmLlC,AEAA,AHAA,AMnLsC,qBAAA,IAAI,CAAC,KAAL,CAAW,OAAX,GAAqB,OAArB;ALoLtC,AEAA,AHAA,AMpLkE,aAAlD,CAAR;ALqLR,AEAA,AHAA,AMpLK,WAFD,MAEO;ALqLX,AEAA,AHAA,AMpLQ,YAAA,QAAQ,CAAC,WAAD,EAAc,UAAA,IAAA,EAAI;ALqLlC,AEAA,AHAA,AMrLsC,qBAAA,IAAI,CAAC,KAAL,CAAW,OAAX,GAAqB,MAArB;ALsLtC,AEAA,AHAA,AMtLiE,aAAjD,CAAR;ALuLR,AEAA,AHAA,AMtLQ,YAAA,QAAQ,CAAC,MAAD,EAAS,UAAA,IAAA,EAAI;ALuL7B,AEAA,AHAA,AMvLiC,qBAAA,IAAI,CAAC,KAAL,CAAW,OAAX,GAAqB,OAArB;ALwLjC,AEAA,AHAA,AMxL6D,aAA7C,CAAR;ALyLR,AEAA,AHAA,AMxLQ,YAAA,QAAQ,CAAC,SAAD,EAAY,UAAA,IAAA,EAAI;ALyLhC,AEAA,AHAA,AMzLoC,qBAAA,IAAI,CAAC,OAAL,GAAe,kBAAf;AL0LpC,AEAA,AHAA,AM1LqE,aAArD,CAAR;AL2LR,AEAA,AHAA,AM1LK;AL2LL,AEAA,AHAA;ACCA,AEAA,AHAA,AM3LI,iBAAA,CAAA;AL4LJ,AEAA,AHAA,AM5LI;AL6LJ,AEAA,AHAA,AM7LI,YAAM,IAAI,CAAC,iBAAL,EAAN,CAAA;AL8LJ,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMhMI,UAAA,EAAA,CAAA,IAAA;ALiMJ,AEAA,AHAA;ACCA,AEAA,AHAA,AMjM0B,iBAAA,CAAA;ALkM1B,AEAA,AHAA,AMlM0B;ALmM1B,AEAA,AHAA,AMnM0B,YAAM,IAAI,CAAC,gBAAL,EAAN,CAAA;ALoM1B,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMtMU,UAAA,aAAa,GAAG,EAAA,CAAA,IAAA,EAAhB;ALuMV,AEAA,AHAA,AMtMI,UAAA,iBAAiB,CAAC,aAAa,CAAC,kBAAf,CAAjB;ALuMJ,AEAA,AHAA,AMtMK,iBAAA,CAAA;ALuML,AEAA,AHAA,AMvMK;ALwML,AEAA,AHAA,AMxMK,YAAM,IAAI,CAAC,SAAL,CAAe,gBAAf,CAAN,CAAA;ALyML,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AM3MK,UAAA,EAAA,CAAA,IAAA,EAAD,CAAyC,EAAzC,CAA4C,MAA5C,EAAoD,UAAA,KAAA,EAAK;AL4M7D,AEAA,AHAA,AM3MQ,YAAA,iBAAiB,CAAC,KAAK,CAAC,kBAAP,CAAjB;AL4MR,AEAA,AHAA,AM3MK,WAFD;AL8MJ,AEAA,AHAA;ACCA,AEAA,AHAA,AM5MU,UAAA,OAAO,GAAG,eAAe,CAAC,aAAa,CAAC,kBAAf,CAAzB;AL6MV,AEAA,AHAA,AM5MI,UAAA,OAAO,CAAC,GAAR,CAAY,kBAAZ,EAAgC,OAAhC;AL6MJ,AEAA,AHAA,AM5MU,UAAA,QAAQ,GAAG,IAAI,IAAI,CAAC,QAAT,CAAkB,SAAA,CAAA,OAAlB,EAAuB,OAAvB,CAAX;AL6MV,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMhN0B,iBAAA,CAAA;ALiN1B,AEAA,AHAA,AMjN0B;ALkN1B,AEAA,AHAA,AMlN0B,YAAM,QAAQ,CAAC,OAAT,CAAiB,SAAjB,CAA2B,EAA3B,EAA+B,IAA/B,EAAN,CAAA;ALmN1B,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA,AMrNc,UAAA,SAAS,GAAG,EAAA,CAAA,IAAA,EAAZ;ALsNd,AEAA,AHAA,AMrNQ,UAAA,OAAO,CAAC,GAAR,CAAY,YAAZ,EAA0B,SAA1B;ALsNR,AEAA,AHAA;ACCA,AEAA,AHAA;ACCA,AEAA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA,AM1NQ,UAAA,OAAO,CAAC,KAAR,CAAc,OAAd;AH2NR,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA,AMpOC;AHqOD,AHAA;AGCA,AHAA,AMpOA,GAAG,GAAG,KAAN,CAAY,OAAO,CAAC,KAApB;AHqOA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA,AHAA;AGCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"App.7a936cda.js","sourceRoot":"../src","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getUniqueId = exports.mergeTransactions = exports.AddressLiteral = exports.Address = void 0;\n/**\n * @category Utils\n */\nclass Address {\n    constructor(address) {\n        this._address = address;\n    }\n    toString() {\n        return this._address;\n    }\n    equals(other) {\n        if (other instanceof Address) {\n            return this._address == other._address;\n        }\n        else {\n            return this._address == other;\n        }\n    }\n}\nexports.Address = Address;\n/**\n * @category Utils\n */\nclass AddressLiteral extends Address {\n    constructor(address) {\n        super(address);\n    }\n}\nexports.AddressLiteral = AddressLiteral;\n/**\n * Modifies knownTransactions array, merging it with new transactions.\n * All arrays are assumed to be sorted by descending logical time.\n *\n * > Note! This method does not remove duplicates.\n *\n * @param knownTransactions\n * @param newTransactions\n * @param info\n *\n * @category Utils\n */\nfunction mergeTransactions(knownTransactions, newTransactions, info) {\n    if (info.batchType == 'old') {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    if (knownTransactions.length === 0) {\n        knownTransactions.push(...newTransactions);\n        return knownTransactions;\n    }\n    // Example:\n    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]\n    // new lts: [N-4, N-5]\n    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }\n    // 1. Skip indices until known transaction lt is greater than the biggest in the batch\n    let i = 0;\n    while (i < knownTransactions.length &&\n        knownTransactions[i].id.lt.localeCompare(info.maxLt) >= 0) {\n        ++i;\n    }\n    // 2. Insert new transactions\n    knownTransactions.splice(i, 0, ...newTransactions);\n    return knownTransactions;\n}\nexports.mergeTransactions = mergeTransactions;\nconst MAX = 4294967295;\nlet idCounter = Math.floor(Math.random() * MAX);\nfunction getUniqueId() {\n    idCounter = (idCounter + 1) % MAX;\n    return idCounter;\n}\nexports.getUniqueId = getUniqueId;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseTokensObject = exports.serializeTokensObject = exports.parseAccountInteraction = exports.parsePermissions = exports.parseMessage = exports.serializeMessage = exports.parseTransaction = exports.serializeTransaction = void 0;\nconst utils_1 = require(\"./utils\");\n/**\n * @category Models\n */\nfunction serializeTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: serializeMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(serializeMessage),\n    };\n}\nexports.serializeTransaction = serializeTransaction;\n/**\n * @category Models\n */\nfunction parseTransaction(transaction) {\n    return {\n        ...transaction,\n        inMessage: parseMessage(transaction.inMessage),\n        outMessages: transaction.outMessages.map(parseMessage),\n    };\n}\nexports.parseTransaction = parseTransaction;\n/**\n * @category Models\n */\nfunction serializeMessage(message) {\n    return {\n        ...message,\n        src: message.src ? message.src.toString() : undefined,\n        dst: message.dst ? message.dst.toString() : undefined,\n    };\n}\nexports.serializeMessage = serializeMessage;\n/**\n * @category Models\n */\nfunction parseMessage(message) {\n    return {\n        ...message,\n        src: message.src ? new utils_1.Address(message.src) : undefined,\n        dst: message.dst ? new utils_1.Address(message.dst) : undefined,\n    };\n}\nexports.parseMessage = parseMessage;\n/**\n * @category Models\n */\nfunction parsePermissions(permissions) {\n    return {\n        ...permissions,\n        accountInteraction: permissions.accountInteraction ? parseAccountInteraction(permissions.accountInteraction) : undefined,\n    };\n}\nexports.parsePermissions = parsePermissions;\n/**\n * @category Models\n */\nfunction parseAccountInteraction(accountInteraction) {\n    return {\n        ...accountInteraction,\n        address: new utils_1.Address(accountInteraction.address),\n    };\n}\nexports.parseAccountInteraction = parseAccountInteraction;\n/**\n * @category Models\n */\nfunction serializeTokensObject(object) {\n    return serializeTokenValue(object);\n}\nexports.serializeTokensObject = serializeTokensObject;\nfunction serializeTokenValue(token) {\n    if (token instanceof utils_1.Address) {\n        return token.toString();\n    }\n    if (Array.isArray(token)) {\n        const result = [];\n        for (const item of token) {\n            result.push(serializeTokenValue(item));\n        }\n        return result;\n    }\n    else if (token != null && typeof token === 'object') {\n        const result = {};\n        for (const [key, value] of Object.entries(token)) {\n            result[key] = serializeTokenValue(value);\n        }\n        return result;\n    }\n    else {\n        return token;\n    }\n}\n/**\n * @category Models\n */\nfunction parseTokensObject(params, object) {\n    const result = {};\n    for (const param of params) {\n        result[param.name] = parseTokenValue(param, object[param.name]);\n    }\n    return result;\n}\nexports.parseTokensObject = parseTokensObject;\nfunction parseTokenValue(param, token) {\n    if (!param.type.startsWith('map')) {\n        const isArray = param.type.endsWith('[]');\n        const isOptional = !isArray && param.type.startsWith('optional');\n        const rawType = (isArray ?\n            param.type.slice(0, -2) :\n            isOptional ?\n                param.type.slice(9, -1) :\n                param.type);\n        if (isArray) {\n            const rawParam = { name: param.name, type: rawType, components: param.components };\n            const result = [];\n            for (const item of token) {\n                result.push(parseTokenValue(rawParam, item));\n            }\n            return result;\n        }\n        else if (isOptional) {\n            if (token == null) {\n                return null;\n            }\n            else {\n                const rawParam = { name: param.name, type: rawType, components: param.components };\n                return parseTokenValue(rawParam, token);\n            }\n        }\n        else if (rawType == 'tuple') {\n            const result = {};\n            if (param.components != null) {\n                for (const component of param.components) {\n                    result[component.name] = parseTokenValue(component, token[component.name]);\n                }\n            }\n            return result;\n        }\n        else if (rawType == 'address') {\n            return new utils_1.Address(token);\n        }\n        else {\n            return token;\n        }\n    }\n    else {\n        let [keyType, valueType] = param.type.split(',');\n        keyType = keyType.slice(4);\n        valueType = valueType.slice(0, -1);\n        const result = [];\n        for (const [key, value] of token) {\n            result.push([parseTokenValue({\n                    name: '',\n                    type: keyType,\n                }, key), parseTokenValue({\n                    name: '',\n                    type: valueType,\n                    components: param.components,\n                }, value)]);\n        }\n        return result;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriber = void 0;\nconst utils_1 = require(\"./utils\");\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = {};\n        this.scanners = {};\n    }\n    /**\n     * Returns stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address);\n    }\n    /**\n     * Returns stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl(async (onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd,\n                ...filter,\n            });\n            this.scanners[id] = scanner;\n            await scanner.start();\n        }, async () => {\n            const scanner = this.scanners[id];\n            delete this.scanners[id];\n            if (scanner != null) {\n                await scanner.stop();\n            }\n        }, identity);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address);\n    }\n    async unsubscribe() {\n        const subscriptions = Object.assign({}, this.subscriptions);\n        for (const address of Object.keys(this.subscriptions)) {\n            delete this.subscriptions[address];\n        }\n        const scanners = Object.assign({}, this.scanners);\n        for (const id of Object.keys(this.scanners)) {\n            delete this.scanners[id];\n        }\n        await Promise.all(Object.values(subscriptions)\n            .map(async (item) => {\n            const events = Object.assign({}, item);\n            for (const event of Object.keys(events)) {\n                delete item[event];\n            }\n            await Promise.all(Object.values(events).map((eventData) => {\n                if (eventData == null) {\n                    return;\n                }\n                return eventData.subscription.then((item) => {\n                    return item.unsubscribe();\n                }).catch(() => {\n                    // ignore\n                });\n            }));\n        }).concat(Object.values(scanners).map((item) => item.stop())));\n    }\n    _addSubscription(event, address) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            let subscriptions = this.subscriptions[address.toString()];\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            if (eventData == null) {\n                const handlers = {\n                    [id]: { onData, onEnd, queue: new PromiseQueue() },\n                };\n                eventData = {\n                    subscription: this.provider.subscribe(event, {\n                        address,\n                    }).then((subscription) => {\n                        subscription.on('data', (data) => {\n                            Object.values(handlers).forEach(({ onData, queue }) => {\n                                queue.enqueue(() => onData(data));\n                            });\n                        });\n                        subscription.on('unsubscribed', () => {\n                            Object.values(handlers).forEach(({ onEnd, queue }) => {\n                                delete handlers[id];\n                                queue.clear();\n                                queue.enqueue(async () => onEnd());\n                            });\n                        });\n                        return subscription;\n                    }).catch((e) => {\n                        console.error(e);\n                        Object.values(handlers).forEach(({ onEnd, queue }) => {\n                            delete handlers[id];\n                            queue.clear();\n                            queue.enqueue(() => onEnd());\n                        });\n                        throw e;\n                    }),\n                    handlers,\n                };\n                if (subscriptions == null) {\n                    subscriptions = {\n                        [event]: eventData,\n                    };\n                    this.subscriptions[address.toString()] = subscriptions;\n                }\n                else {\n                    subscriptions[event] = eventData;\n                }\n            }\n            else {\n                eventData.handlers[id] = { onData, onEnd, queue: new PromiseQueue() };\n            }\n        }, () => {\n            const subscriptions = this.subscriptions[address.toString()];\n            if (subscriptions == null) {\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                delete eventData.handlers[id];\n                if (Object.keys(eventData.handlers).length === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            if (Object.keys(subscriptions).length === 0) {\n                delete this.subscriptions[address.toString()];\n            }\n        }, identity);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(event, handler) {\n    await handler(event);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n    }\n    first() {\n        return new Promise(async (resolve, reject) => {\n            this.makeProducer(async (event) => {\n                await this.extractor(event, (item) => {\n                    this.stopProducer();\n                    resolve(item);\n                });\n            }, () => reject(new Error('Subscription closed')));\n        });\n    }\n    on(handler) {\n        this.makeProducer(async (event) => {\n            await this.extractor(event, handler);\n        }, () => {\n        });\n    }\n    merge(other) {\n        return new StreamImpl(async (onEvent, onEnd) => {\n            const state = {\n                counter: 0,\n            };\n            const checkEnd = () => {\n                if (++state.counter == 2) {\n                    onEnd();\n                }\n            };\n            this.makeProducer(onEvent, checkEnd);\n            other.makeProducer(onEvent, checkEnd);\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                await handler(item);\n            }\n        }));\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                await handler(newItem);\n            }\n        }));\n    }\n    map(f) {\n        return this.filterMap(f);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                await handler(newItem);\n            }\n        }));\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (state.index >= n) {\n                await handler(item);\n            }\n            else {\n                ++state.index;\n            }\n        }));\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                await handler(item);\n            }\n        }));\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, { address, onData, onEnd, fromLt, fromUtime, }) {\n        this.provider = provider;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.address = address;\n        this.onData = onData;\n        this.onEnd = onEnd;\n        this.fromLt = fromLt;\n        this.fromUtime = fromUtime;\n    }\n    async start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            while (this.isRunning) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.address,\n                        continuation: this.continuation,\n                    });\n                    if (!this.isRunning || transactions.length == null) {\n                        break;\n                    }\n                    const filteredTransactions = transactions.filter((item) => ((this.fromLt == null || item.id.lt > this.fromLt) && ((this.fromUtime == null || item.createdAt > this.fromUtime))));\n                    if (filteredTransactions.length == 0) {\n                        break;\n                    }\n                    const info = {\n                        maxLt: filteredTransactions[0].id.lt,\n                        minLt: filteredTransactions[filteredTransactions.length - 1].id.lt,\n                        batchType: 'old',\n                    };\n                    this.queue.enqueue(() => this.onData({\n                        address: this.address,\n                        transactions: filteredTransactions,\n                        info,\n                    }));\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.onEnd());\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.onEnd();\n        }\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TvmException = exports.Contract = void 0;\nconst models_1 = require(\"./models\");\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this._functions = abi.functions.reduce((functions, item) => {\n            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };\n            return functions;\n        }, {});\n        this._events = abi.events.reduce((events, item) => {\n            events[item.name] = { inputs: item.inputs || [] };\n            return events;\n        }, {});\n        this._address = address;\n        class ContractMethodImpl {\n            constructor(provider, functionAbi, abi, address, method, params) {\n                this.provider = provider;\n                this.functionAbi = functionAbi;\n                this.abi = abi;\n                this.address = address;\n                this.method = method;\n                this.params = (0, models_1.serializeTokensObject)(params);\n            }\n            async send(args) {\n                const { transaction } = await this.provider.rawApi.sendMessage({\n                    sender: args.from.toString(),\n                    recipient: this.address.toString(),\n                    amount: args.amount,\n                    bounce: args.bounce == null ? true : args.bounce,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                return (0, models_1.parseTransaction)(transaction);\n            }\n            async sendWithResult(args) {\n                const subscriber = this.provider.createSubscriber();\n                try {\n                    // Parent transaction from wallet\n                    let parentTransaction;\n                    // Child transaction promise\n                    let resolveChildTransactionPromise;\n                    const childTransactionPromise = new Promise((resolve) => {\n                        resolveChildTransactionPromise = (tx) => resolve(tx);\n                    });\n                    // Array for collecting transactions on target before parent transaction promise resolution\n                    const possibleChildren = [];\n                    // Subscribe to this account\n                    subscriber.transactions(this.address)\n                        .flatMap(batch => batch.transactions)\n                        // Listen only messages from sender\n                        .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                        .on((tx) => {\n                        if (parentTransaction == null) {\n                            // If we don't known whether the message was sent just collect all transactions from the sender\n                            possibleChildren.push(tx);\n                        }\n                        else if (parentTransaction.possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0) {\n                            // Resolve promise if transaction was found\n                            resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                        }\n                    });\n                    // Send message\n                    const transaction = await this.send(args);\n                    // Extract all outgoing messages from the parent transaction to this contract\n                    const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n                    // Update stream state\n                    parentTransaction = {\n                        transaction,\n                        possibleMessages,\n                    };\n                    // Check whether child transaction was already found\n                    const alreadyReceived = possibleChildren.find((tx) => {\n                        return possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0;\n                    });\n                    if (alreadyReceived != null) {\n                        resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n                    }\n                    const childTransaction = await childTransactionPromise;\n                    // Parse output\n                    let output = undefined;\n                    try {\n                        const result = await this.provider.rawApi.decodeTransaction({\n                            transaction: (0, models_1.serializeTransaction)(childTransaction),\n                            abi: this.abi,\n                            method: this.method,\n                        });\n                        if (result != null) {\n                            output = this.functionAbi.outputs != null\n                                ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output)\n                                : {};\n                        }\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                    // Done\n                    return {\n                        parentTransaction: parentTransaction.transaction,\n                        childTransaction,\n                        output,\n                    };\n                }\n                finally {\n                    await subscriber.unsubscribe();\n                }\n            }\n            async estimateFees(args) {\n                const { fees } = await this.provider.rawApi.estimateFees({\n                    sender: args.from.toString(),\n                    recipient: this.address.toString(),\n                    amount: args.amount,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                return fees;\n            }\n            async sendExternal(args) {\n                let method = args.withoutSignature === true\n                    ? this.provider.rawApi.sendUnsignedExternalMessage\n                    : this.provider.rawApi.sendExternalMessage;\n                let { transaction, output } = await method({\n                    publicKey: args.publicKey,\n                    recipient: this.address.toString(),\n                    stateInit: args.stateInit,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                    local: args.local,\n                });\n                return {\n                    transaction: (0, models_1.parseTransaction)(transaction),\n                    output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n                };\n            }\n            async call(args = {}) {\n                let { output, code } = await this.provider.rawApi.runLocal({\n                    address: this.address.toString(),\n                    cachedState: args.cachedState,\n                    responsible: args.responsible,\n                    functionCall: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                if (output == null || code != 0) {\n                    throw new TvmException(code);\n                }\n                else {\n                    return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n                }\n            }\n        }\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this._functions[method];\n                return (params) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    async decodeTransaction(args) {\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, input, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this._events[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, input } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProviderNotInitializedException = exports.ProviderNotFoundException = exports.ProviderRpcClient = exports.hasEverscaleProvider = exports.mergeTransactions = exports.AddressLiteral = exports.Address = exports.Subscriber = void 0;\nconst models_1 = require(\"./models\");\nconst utils_1 = require(\"./utils\");\nconst subscriber = __importStar(require(\"./stream\"));\nconst contract = __importStar(require(\"./contract\"));\n__exportStar(require(\"./api\"), exports);\n__exportStar(require(\"./models\"), exports);\n__exportStar(require(\"./contract\"), exports);\nvar stream_1 = require(\"./stream\");\nObject.defineProperty(exports, \"Subscriber\", { enumerable: true, get: function () { return stream_1.Subscriber; } });\nvar utils_2 = require(\"./utils\");\nObject.defineProperty(exports, \"Address\", { enumerable: true, get: function () { return utils_2.Address; } });\nObject.defineProperty(exports, \"AddressLiteral\", { enumerable: true, get: function () { return utils_2.AddressLiteral; } });\nObject.defineProperty(exports, \"mergeTransactions\", { enumerable: true, get: function () { return utils_2.mergeTransactions; } });\nlet ensurePageLoaded;\nif (document.readyState == 'complete') {\n    ensurePageLoaded = Promise.resolve();\n}\nelse {\n    ensurePageLoaded = new Promise((resolve) => {\n        window.addEventListener('load', () => {\n            resolve();\n        });\n    });\n}\n/**\n * @category Provider\n */\nasync function hasEverscaleProvider() {\n    await ensurePageLoaded;\n    return window.__hasEverscaleProvider === true;\n}\nexports.hasEverscaleProvider = hasEverscaleProvider;\n/**\n * @category Provider\n */\nclass ProviderRpcClient {\n    constructor(properties = {}) {\n        this._subscriptions = {};\n        this._contractSubscriptions = {};\n        const self = this;\n        // Create contract proxy type\n        class ProviderContract extends contract.Contract {\n            constructor(abi, address) {\n                super(self, abi, address);\n            }\n        }\n        this.Contract = ProviderContract;\n        // Create subscriber proxy type\n        class ProviderSubscriber extends subscriber.Subscriber {\n            constructor() {\n                super(self);\n            }\n        }\n        this.Subscriber = ProviderSubscriber;\n        this._properties = properties;\n        // Wrap provider requests\n        this._api = new Proxy({}, {\n            get: (_object, method) => (params) => {\n                if (this._provider != null) {\n                    return this._provider.request({ method, params: params });\n                }\n                else {\n                    throw new ProviderNotInitializedException();\n                }\n            },\n        });\n        // Initialize provider with injected object by default\n        this._provider = window.__ever;\n        if (this._provider != null) {\n            // Provider as already injected\n            this._mainInitializationPromise = Promise.resolve();\n        }\n        else {\n            // Wait until page is loaded and initialization complete\n            this._mainInitializationPromise = hasEverscaleProvider().then((hasProvider) => new Promise((resolve, reject) => {\n                if (!hasProvider) {\n                    // Fully loaded page doesn't even contain provider flag\n                    reject(new ProviderNotFoundException());\n                    return;\n                }\n                // Wait injected provider initialization otherwise\n                this._provider = window.__ever;\n                if (this._provider != null) {\n                    resolve();\n                }\n                else {\n                    window.addEventListener('ever#initialized', (_data) => {\n                        this._provider = window.__ever;\n                        resolve();\n                    });\n                }\n            }));\n        }\n        // Will only register handlers for successfully loaded injected provider\n        this._mainInitializationPromise.then(() => {\n            if (this._provider != null) {\n                this._registerEventHandlers(this._provider);\n            }\n        });\n    }\n    /**\n     * Checks whether this page has injected Everscale provider\n     */\n    async hasProvider() {\n        return hasEverscaleProvider();\n    }\n    /**\n     * Waits until provider api will be available. Calls `fallback` if no provider was found\n     *\n     * @throws ProviderNotFoundException when no provider found\n     */\n    async ensureInitialized() {\n        try {\n            await this._mainInitializationPromise;\n        }\n        catch (e) {\n            if (this._properties.fallback == null) {\n                throw e;\n            }\n            if (this._additionalInitializationPromise == null) {\n                this._additionalInitializationPromise = this._properties.fallback().then(async (provider) => {\n                    this._provider = provider;\n                    this._registerEventHandlers(this._provider);\n                });\n            }\n            await this._additionalInitializationPromise;\n        }\n    }\n    /**\n     * Whether provider api is ready\n     */\n    get isInitialized() {\n        return this._provider != null;\n    }\n    /**\n     * Raw provider\n     */\n    get raw() {\n        if (this._provider != null) {\n            return this._provider;\n        }\n        else {\n            throw new ProviderNotInitializedException();\n        }\n    }\n    /**\n     * Raw provider api\n     */\n    get rawApi() {\n        return this._api;\n    }\n    /**\n     * Creates typed contract wrapper.\n     *\n     * @param abi Readonly object (must be declared with `as const`)\n     * @param address Default contract address\n     *\n     * @deprecated `new ever.Contract(abi, address)` should be used instead\n     */\n    createContract(abi, address) {\n        return new this.Contract(abi, address);\n    }\n    /**\n     * Creates subscriptions group\n     *\n     * @deprecated `new ever.Subscriber()` should be used instead\n     */\n    createSubscriber() {\n        return new this.Subscriber();\n    }\n    /**\n     * Requests new permissions for current origin.\n     * Shows an approval window to the user.\n     * Will overwrite already existing permissions\n     *\n     * ---\n     * Required permissions: none\n     */\n    async requestPermissions(args) {\n        const result = await this._api.requestPermissions({\n            permissions: args.permissions,\n        });\n        return (0, models_1.parsePermissions)(result);\n    }\n    /**\n     * Updates `accountInteraction` permission value\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async changeAccount() {\n        await this._api.changeAccount();\n    }\n    /**\n     * Removes all permissions for current origin and stops all subscriptions\n     */\n    async disconnect() {\n        await this._api.disconnect();\n    }\n    async subscribe(eventName, params) {\n        class SubscriptionImpl {\n            constructor(_subscribe, _unsubscribe) {\n                this._subscribe = _subscribe;\n                this._unsubscribe = _unsubscribe;\n                this._listeners = {\n                    ['data']: [],\n                    ['subscribed']: [],\n                    ['unsubscribed']: [],\n                };\n            }\n            on(eventName, listener) {\n                this._listeners[eventName].push(listener);\n                return this;\n            }\n            async subscribe() {\n                await this._subscribe(this);\n                for (const handler of this._listeners['subscribed']) {\n                    handler();\n                }\n            }\n            async unsubscribe() {\n                await this._unsubscribe();\n                for (const handler of this._listeners['unsubscribed']) {\n                    handler();\n                }\n            }\n            notify(data) {\n                for (const handler of this._listeners['data']) {\n                    handler(data);\n                }\n            }\n        }\n        let existingSubscriptions = this._getEventSubscriptions(eventName);\n        const id = (0, utils_1.getUniqueId)();\n        switch (eventName) {\n            case 'connected':\n            case 'disconnected':\n            case 'networkChanged':\n            case 'permissionsChanged':\n            case 'loggedOut': {\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions[id] != null) {\n                        return;\n                    }\n                    existingSubscriptions[id] = (data) => {\n                        subscription.notify(data);\n                    };\n                }, async () => {\n                    delete existingSubscriptions[id];\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            case 'transactionsFound':\n            case 'contractStateChanged': {\n                const address = params.address.toString();\n                const subscription = new SubscriptionImpl(async (subscription) => {\n                    if (existingSubscriptions[id] != null) {\n                        return;\n                    }\n                    existingSubscriptions[id] = ((data) => {\n                        if (data.address.toString() == address) {\n                            subscription.notify(data);\n                        }\n                    });\n                    let contractSubscriptions = this._contractSubscriptions[address];\n                    if (contractSubscriptions == null) {\n                        contractSubscriptions = {};\n                        this._contractSubscriptions[address] = contractSubscriptions;\n                    }\n                    contractSubscriptions[id] = {\n                        state: eventName == 'contractStateChanged',\n                        transactions: eventName == 'transactionsFound',\n                    };\n                    const { total, withoutExcluded, } = foldSubscriptions(Object.values(contractSubscriptions), contractSubscriptions[id]);\n                    try {\n                        if (total.transactions != withoutExcluded.transactions || total.state != withoutExcluded.state) {\n                            await this.rawApi.subscribe({ address, subscriptions: total });\n                        }\n                    }\n                    catch (e) {\n                        delete existingSubscriptions[id];\n                        delete contractSubscriptions[id];\n                        throw e;\n                    }\n                }, async () => {\n                    delete existingSubscriptions[id];\n                    const contractSubscriptions = this._contractSubscriptions[address];\n                    if (contractSubscriptions == null) {\n                        return;\n                    }\n                    const updates = contractSubscriptions[id];\n                    const { total, withoutExcluded } = foldSubscriptions(Object.values(contractSubscriptions), updates);\n                    delete contractSubscriptions[id];\n                    if (!withoutExcluded.transactions && !withoutExcluded.state) {\n                        await this.rawApi.unsubscribe({ address });\n                    }\n                    else if (total.transactions != withoutExcluded.transactions || total.state != withoutExcluded.state) {\n                        await this.rawApi.subscribe({ address, subscriptions: withoutExcluded });\n                    }\n                });\n                await subscription.subscribe();\n                return subscription;\n            }\n            default: {\n                throw new Error(`Unknown event ${eventName}`);\n            }\n        }\n    }\n    /**\n     * Returns provider api state\n     *\n     * ---\n     * Required permissions: none\n     */\n    async getProviderState() {\n        const state = await this._api.getProviderState();\n        return {\n            ...state,\n            permissions: (0, models_1.parsePermissions)(state.permissions),\n        };\n    }\n    /**\n     * Requests contract data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getFullContractState(args) {\n        return await this._api.getFullContractState({\n            address: args.address.toString(),\n        });\n    }\n    /**\n     * Requests accounts with specified code hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getAccountsByCodeHash(args) {\n        const { accounts, continuation } = await this._api.getAccountsByCodeHash({\n            ...args,\n        });\n        return {\n            accounts: accounts.map((address) => new utils_1.Address(address)),\n            continuation,\n        };\n    }\n    /**\n     * Requests contract transactions\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransactions(args) {\n        const { transactions, continuation, info } = await this._api.getTransactions({\n            ...args,\n            address: args.address.toString(),\n        });\n        return {\n            transactions: transactions.map(models_1.parseTransaction),\n            continuation,\n            info,\n        };\n    }\n    /**\n     * Searches transaction by hash\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getTransaction(args) {\n        const { transaction } = await this._api.getTransaction({\n            ...args,\n        });\n        return {\n            transaction: transaction ? (0, models_1.parseTransaction)(transaction) : undefined,\n        };\n    }\n    /**\n     * Calculates contract address from code and init params\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getExpectedAddress(abi, args) {\n        const { address } = await this._api.getExpectedAddress({\n            abi: JSON.stringify(abi),\n            ...args,\n            initParams: (0, models_1.serializeTokensObject)(args.initParams),\n        });\n        return new utils_1.Address(address);\n    }\n    /**\n     * Computes hash of base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async getBocHash(boc) {\n        return await this._api.getBocHash({\n            boc,\n        }).then(({ hash }) => hash);\n    }\n    /**\n     * Creates base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async packIntoCell(args) {\n        return await this._api.packIntoCell({\n            structure: args.structure,\n            data: (0, models_1.serializeTokensObject)(args.data),\n        });\n    }\n    /**\n     * Decodes base64 encoded BOC\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async unpackFromCell(args) {\n        const { data } = await this._api.unpackFromCell({\n            ...args,\n            structure: args.structure,\n        });\n        return {\n            data: (0, models_1.parseTokensObject)(args.structure, data),\n        };\n    }\n    /**\n     * Extracts public key from raw account state\n     *\n     * **NOTE:** can only be used on contracts which are deployed and has `pubkey` header\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async extractPublicKey(boc) {\n        const { publicKey } = await this._api.extractPublicKey({\n            boc,\n        });\n        return publicKey;\n    }\n    /**\n     * Converts base64 encoded contract code into tvc with default init data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async codeToTvc(code) {\n        const { tvc } = await this._api.codeToTvc({\n            code,\n        });\n        return tvc;\n    }\n    /**\n     * Splits base64 encoded state init into code and data\n     *\n     * ---\n     * Required permissions: `basic`\n     */\n    async splitTvc(tvc) {\n        return await this._api.splitTvc({\n            tvc,\n        });\n    }\n    /**\n     * Adds asset to the selected account\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async addAsset(args) {\n        let params;\n        switch (args.type) {\n            case 'tip3_token': {\n                params = {\n                    rootContract: args.params.rootContract.toString(),\n                };\n                break;\n            }\n            default:\n                throw new Error('Unknown asset type');\n        }\n        return await this._api.addAsset({\n            account: args.account.toString(),\n            type: args.type,\n            params,\n        });\n    }\n    async verifySignature(args) {\n        return await this._api.verifySignature(args);\n    }\n    /**\n     * Signs arbitrary data.\n     *\n     * NOTE: hashes data before signing. Use `signDataRaw` to sign without hash.\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signData(args) {\n        return await this._api.signData(args);\n    }\n    /**\n     * Signs arbitrary data without hashing it\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async signDataRaw(args) {\n        return await this._api.signDataRaw(args);\n    }\n    /**\n     * Encrypts arbitrary data with specified algorithm for each specified recipient\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async encryptData(args) {\n        const { encryptedData } = await this._api.encryptData(args);\n        return encryptedData;\n    }\n    /**\n     * Decrypts encrypted data. Returns base64 encoded data\n     *\n     * ---\n     * Requires permissions: `accountInteraction`\n     */\n    async decryptData(encryptedData) {\n        const { data } = await this._api.decryptData({ encryptedData });\n        return data;\n    }\n    /**\n     * Sends internal message from user account.\n     * Shows an approval window to the user.\n     *\n     * ---\n     * Required permissions: `accountInteraction`\n     */\n    async sendMessage(args) {\n        const { transaction } = await this._api.sendMessage({\n            ...args,\n            sender: args.sender.toString(),\n            recipient: args.recipient.toString(),\n            payload: args.payload ? ({\n                abi: args.payload.abi,\n                method: args.payload.method,\n                params: (0, models_1.serializeTokensObject)(args.payload.params),\n            }) : undefined,\n        });\n        return {\n            transaction: (0, models_1.parseTransaction)(transaction),\n        };\n    }\n    _registerEventHandlers(provider) {\n        const knownEvents = {\n            'connected': (data) => data,\n            'disconnected': (data) => data,\n            'transactionsFound': (data) => ({\n                address: new utils_1.Address(data.address),\n                transactions: data.transactions.map(models_1.parseTransaction),\n                info: data.info,\n            }),\n            'contractStateChanged': (data) => ({\n                address: new utils_1.Address(data.address),\n                state: data.state,\n            }),\n            'networkChanged': data => data,\n            'permissionsChanged': (data) => ({\n                permissions: (0, models_1.parsePermissions)(data.permissions),\n            }),\n            'loggedOut': data => data,\n        };\n        for (const [eventName, extractor] of Object.entries(knownEvents)) {\n            provider.addListener(eventName, (data) => {\n                const handlers = this._subscriptions[eventName];\n                if (handlers == null) {\n                    return;\n                }\n                const parsed = extractor(data);\n                for (const handler of Object.values(handlers)) {\n                    handler(parsed);\n                }\n            });\n        }\n    }\n    _getEventSubscriptions(eventName) {\n        let existingSubscriptions = this._subscriptions[eventName];\n        if (existingSubscriptions == null) {\n            existingSubscriptions = {};\n            this._subscriptions[eventName] = existingSubscriptions;\n        }\n        return existingSubscriptions;\n    }\n}\nexports.ProviderRpcClient = ProviderRpcClient;\n/**\n * @category Provider\n */\nclass ProviderNotFoundException extends Error {\n    constructor() {\n        super('Everscale provider was not found');\n    }\n}\nexports.ProviderNotFoundException = ProviderNotFoundException;\n/**\n * @category Provider\n */\nclass ProviderNotInitializedException extends Error {\n    constructor() {\n        super('Everscale provider was not initialized yet');\n    }\n}\nexports.ProviderNotInitializedException = ProviderNotInitializedException;\nfunction foldSubscriptions(subscriptions, except) {\n    const total = { state: false, transactions: false };\n    const withoutExcluded = Object.assign({}, total);\n    for (const item of subscriptions) {\n        if (withoutExcluded.transactions && withoutExcluded.state) {\n            break;\n        }\n        total.state || (total.state = item.state);\n        total.transactions || (total.transactions = item.transactions);\n        if (item != except) {\n            withoutExcluded.state || (withoutExcluded.state = item.state);\n            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);\n        }\n    }\n    return { total, withoutExcluded };\n}\n","export default {\"ABI version\":2,\"version\":\"2.2\",\"header\":[\"time\",\"expire\"],\"functions\":[{\"name\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"name\":\"renderHelloWorld\",\"inputs\":[],\"outputs\":[{\"name\":\"value0\",\"type\":\"string\"}]},{\"name\":\"touch\",\"inputs\":[],\"outputs\":[]},{\"name\":\"sendValue\",\"inputs\":[{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint128\"},{\"name\":\"bounce\",\"type\":\"bool\"}],\"outputs\":[]},{\"name\":\"timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint32\"}]}],\"data\":[],\"events\":[],\"fields\":[{\"name\":\"_pubkey\",\"type\":\"uint256\"},{\"name\":\"_timestamp\",\"type\":\"uint64\"},{\"name\":\"_constructorFlag\",\"type\":\"bool\"},{\"name\":\"timestamp\",\"type\":\"uint32\"}]} as const\n","export default {\"testnet\": {\"App\": \"0:706a1e011e8faaeb2949f95c8673022d470e523e5fddc5b230591397675c1dd3\"},}\n","import {Address, ProviderRpcClient,} from 'everscale-inpage-provider'\nimport abi from '../build/App.abi'\nimport addr from '../build/App.addr'\n\nconst ever = new ProviderRpcClient()\n\nfunction behavior(name: string, fn: (elem: HTMLElement | HTMLButtonElement | HTMLInputElement) => void) {\n    document.querySelectorAll(`[data-behavior=${name}]`).forEach(fn)\n}\n\nfunction requestPermissions() {\n    return ever.requestPermissions({\n        permissions: [\n            'basic',\n            'accountInteraction',\n        ],\n    })\n}\n\nasync function connect() {\n    await ever.requestPermissions({\n        permissions: [\n            'basic',\n            'accountInteraction',\n        ],\n    });\n}\n\nfunction setNetworkChanged(network: string) {\n    const mod = network === 'mainnet' ? 'success' : 'secondary'\n    behavior(\n        'network',\n        elem => elem.innerHTML = `<span class=\"badge bg-${mod}\">${network}</span>`\n    )\n    behavior(\n        'connect',\n        elem => {\n            const disabled = !contractAddress(network)\n            if (\"disabled\" in elem) elem.disabled = disabled\n            elem.innerText = disabled ? `Contract not deployd into ${network}`: `Connect with ${network} for interact contract`\n        }\n    )\n}\n\nfunction contractAddress(network: string, name = \"App\"): Address | null {\n    if (addr[network] && addr[network][name]) {\n        return new Address(addr[network][name])\n    }\n    return null;\n}\n\nasync function App() {\n    if (!(await ever.hasProvider())) {\n        behavior('extension', elem => elem.style.display = 'block')\n    } else {\n        behavior('extension', elem => elem.style.display = 'none')\n        behavior('main', elem => elem.style.display = 'block')\n        behavior('connect', elem => elem.onclick = requestPermissions)\n    }\n    await ever.ensureInitialized()\n    const providerState = await ever.getProviderState()\n    setNetworkChanged(providerState.selectedConnection);\n    (await ever.subscribe('networkChanged')).on('data', event => {\n        setNetworkChanged(event.selectedConnection)\n    })\n    const address = contractAddress(providerState.selectedConnection);\n    console.log('contractAddress:', address)\n    const contract = new ever.Contract(abi, address)\n    try {\n        const timestamp = await contract.methods.timestamp({}).call()\n        console.log('timestamp:', timestamp);\n    } catch (error) {\n        console.error(error)\n    }\n}\n\nApp().catch(console.error)\n"]}